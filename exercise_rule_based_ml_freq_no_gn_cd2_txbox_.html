<!DOCTYPE html>
<html lang="en-US">
<head>
  <title>HLSI Exercise - Frequency Rule Based Adaptation </title>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width"/>
  <meta name="author" content=""/>
  <meta name="keywords" content=""/>
  <meta name="description" content=""/>
  <link rel="stylesheet" type="text/css" media="all" href="base.css">
</head>

<body>
  <h2>Exercise - Frequency Rule Based Adaptation</h2>
  <p><a href="index.html">[exercises]</a></p>
  <!--<p><input id="restart" type="button" value="Start" onclick="restart()"></p> -->

  <p><label for="userfunction" class="callback_description">
      Fill out a function to change the gain, the bandwidth, the modulation and coding, this variables must be changed in order:
  </label></p>
  <p ><tt class="callback_description1">function callback(  gain, bandWidth, Modulation and Coding   ) {</tt> </p>
  <div class ="container">
  <div class = "fixed">
  <p><textarea id="userfunction" name="userfunction" rows="18" cols="90" 
      maxlength=2048 autofocus=true style="color:white;font: 1em monospace;"
      placeholder="return {'gain1':2, 'bw1':120, 'mcs1':0};">return {'gain1':2, 'bw1':120, 'mcs1':0};</textarea></p>
	  </div>

</div>

    <p><input id="restart" type="button" value="Start" onclick="toggle()">&nbsp;
  <label for="strategy" hidden >Select pre-configured strategy:</label>
  <select id="strategy" onchange="populateCallback()">
    <option value="default" selected >Select pre-configured strategy...</option>
   <!-- <option value="a0">Maximum Bandwidth, Minimum Modulation and Coding</option> -->
    <option value="a1">Random Frequency Adaptation</option>
    <option value="a2">Frequency-based Adaptation, Narrow-band</option>
    <option value="a3">Gain Adaptation</option>
    <option value="a4">Gain Adaptation with Controllable Interference</option>
    <option value="a5">Gain Adaptation,  Sensing and  Controllable Interference</option>

	<!-- <option value="a3">Frequency-based Adaptation, Approx. Half-band</option> -->
    <!--<option value="a4">Frequency and Bandwidth-based Adaptation (Maximum Contiguous Bandwidth)</option> -->
  </select>
  </p>
  <p>
  </p>
  <p>
    <label for="frequency">Frequency</label>
    <input class="width-3" type="range" min="-0.5" max="0.5" value="0.0" id="frequency" step="0.001" oninput="update_plot(parseFloat(value),null,null, null)">
    <output for="frequency" id="fc">1800.0 MHz</output>
  </p>
  <p>
    <label for="bandwidth">Bandwidth</label>
    <input class="width-3" type="range" min="0.19" max="0.9" value="0.19" id="bandwidth" step="0.001"
        oninput="update_plot(null,parseFloat(value),null, null)">
    <output for="bandwidth" id="bw">0.1</output>
  </p>
  <p>
    <label for="modcod">Mod./Coding</label>
    <input class="width-3" type="range" min="0" max="11" value="0" id="modcod" step="1"
        oninput="update_plot(null,null,null,parseInt(value))">
    <output for="modcod" id="mc"></output>
  </p>
  <!--
    <p>
    <label for="hop_rate">Hop Rate</label>
    <input class="width-3" type="range" min="0.2" max="2" value="0" id="hop_rate" step="0.01"
        oninput="update_hop_rate(parseFloat(value))">
    <output for="hop_rate" id="hr"></output>
  </p>
-->
<!--
    <div>
    <input type="radio" id="hr_slow"
     name="hop" value="slow" onclick="update_hop_rate(parseInt(value) ,null)">
    <label for="hr_slow">0.2 Hz</label>

    <input type="radio" id="hr_fast"
     name="hop" value="fast" onclick="update_hop_rate(null, parseInt(value))">
    <label for="hr_fast">2 Hz</label>

  </div>
  
    <div>
    <input type="radio" id="slow"
     name="sensing" value="slow" onclick="adjust_dwell(parseInt(value) ,null)">
    <label for="slow">Slow Sensing</label>

    <input type="radio" id="fast"
     name="sensing" value="fast" onclick="adjust_dwell(null, parseInt(value))">
    <label for="fast">Fast Sensing</label>

  </div>
  -->
  <p>
    <label for="signal_to_noise_ratio">SNR:       </label><output for="signal_to_noise_ratio" id="snr"    class="text-bold"></output>,
    <label for="information_capacity">Capacity:   </label><output for="information_capacity"  id="cap"    class="text-bold"></output>,
    <label for="spectral_efficiency">Spect. Eff.: </label><output for="spectral_efficiency"   id="eta"    class="text-bold"></output>
    <label for="link_margin">Margin:              </label><output for="link_margin"           id="margin" class="text-bold"></output>,
    <label for="actual_rate">Actual Rate:         </label><output for="actual_rate"           id="rate"   class="text-bold"></output>

	
  </p>
  <p>
    <label for="time_left"> Time Left:  </label><output for="time_left"  id="timer"   class="text-bold"></output>,
    <label for="outages">   Outages:    </label><output for="outages"    id="outages" class="text-bold"></output>,
    <label for="outages_survived">   Outages avoided by sensing:    </label><output for="outages_survived"    id="outages_survived" class="text-bold"></output>,
    <label for="total_bits">Total Bits: </label><output for="total_bits" id="bits"    class="text-bold"></output>
  </p>
  
  <p>
       <label for="signal_frequency">Signal Frequency:         </label><output for="signal_frequency"           id="frequency_"   class="text-bold"></output>,
	  <label for="signal_bandwidth">Signal Bandwidth:         </label><output for="signal_bandwidth"           id="bw_"   class="text-bold"></output>,
	         <label for="">Gain:         </label><output for="gn"           id="gain"   class="text-bold"></output>

  </p>
  
    <p>
       <label for="interferer_frequency">Interference Frequency:         </label><output for="interferer_frequency"           id="frequency_int"   class="text-bold"></output>,
	  <label for="interferer_bandwidth">Interference Bandwidth:         </label><output for="signal_bandwidth"           id="bw_int"   class="text-bold"></output>.

  </p>
  
      <p>
       <label for="temporary1">Temporary 1:         </label><output for="temporary1"           id="temp1"   class="text-bold"></output>,
       <label for="temporary2">Temporary 2:         </label><output for="temporary2"           id="temp2"   class="text-bold"></output>,
       <label for="temporary3">Temporary 3:         </label><output for="temporary3"           id="temp3"   class="text-bold"></output>,
       <label for="temporary4">Temporary 4:         </label><output for="temporary4"           id="temp4"   class="text-bold"></output>,
       <label for="temporary5">Temporary 5:         </label><output for="temporary5"           id="temp5"   class="text-bold"></output>,

  </p>

</body>

<!-- Load in the javascript libraries -->
<script src="d3.v5.min.js"></script>
<script src="fft.js"></script>
<script src="support.js"></script>
<script>

// 2. Use the margin convention practice
var margin = {top: 10, right: 50, bottom: 50, left: 50}
  , width  = 720 - margin.left - margin.right  // Use the window's width
  , height = 320 - margin.top - margin.bottom; // Use the window's height

var temp1 = 0, temp2 = 0, temp3 = 0, temp4 = 0, temp5 = 0, temp1a = 0;

// options
var fs = 40e6, f0 = 1800e6;     // sample rate, center frequency
var f_limit = 0.44;
var uIndex = -1;
var uIndexHop = -1;
var checkSensing = 1;
var running = true;
var bw = 0.19, fc = 0.0, gn = 2, mc = 0, n0 = -30, snr = 0, rate = 0, valid = false, valid2= false;
var nfft = 2048, generator = new siggen(nfft);
generator.m    = 40;  // set filter semi-length
generator.beta = 1.5; // set filter window exponent (smaller shows more side-lobes)
var bw_int = 0.05, fc_int = 0.35, gn_int = -2; // interference values
var hop_dwell_time = 200;
var alpha = 0.5;
var counter=0, bits=0, outages=0, outages_survived=0, runtime=60, step_dwell_time=50;
var fc_saved = -9;
var hop_check = 0;
var hop_rate = 0.2;
var outages_check =0;
var num_steps = Math.round(runtime * 1000 / step_dwell_time);
hop_dwell_time = step_dwell_time;
var adjust_dwell_time = 1.5;
var margin_dB = 0;
var gn_offset = 1;
var schemes = [
    {'rate':0.50000, 'SNR': 3.979, 'name':'r1/2 BPSK'},
    {'rate':0.66667, 'SNR': 5.703, 'name':'r2/3 BPSK'},
    {'rate':1.00000, 'SNR': 7.109, 'name':'r1/2 QPSK'},
    {'rate':1.33333, 'SNR': 8.782, 'name':'r2/3 QPSK'},
    {'rate':1.77778, 'SNR':10.202, 'name':'r8/9 QPSK'},
    {'rate':2.66667, 'SNR':15.036, 'name':'r2/3 16-QAM'},
    {'rate':3.55556, 'SNR':16.747, 'name':'r8/9 16-QAM'},
    {'rate':4.44444, 'SNR':20.970, 'name':'r8/9 32-QAM'},
    {'rate':5.33333, 'SNR':22.920, 'name':'r8/9 64-QAM'},
    {'rate':6.22222, 'SNR':26.797, 'name':'r8/9 128-QAM'},
    {'rate':7.11111, 'SNR':28.570, 'name':'r8/9 256-QAM'},
    {'rate':8.00000, 'SNR':31.050, 'name':'uncoded 256-QAM'}]

// determine scale/units
var [scale_freq,units_freq] = scale_units(f0+fs/2,0.1);
var fs_ = 400e6; 
var [scale_freq_,units_freq_] = scale_units(f0+fs_/2,0.01);

var fScale = d3.scaleLinear().domain([(f0-0.5*fs_)*scale_freq_, (f0+0.5*fs_)*scale_freq_]).range([0, width]);
var pScale = d3.scaleLinear().domain([-35, 25]).range([height, 0]);

// d3's line generator
var linef = d3.line()
    .x(function(d, i) { return fScale((f0+(i/nfft-0.5)*fs_)*scale_freq_); })  // map frequency
    .y(function(d)    { return pScale(d.y);        }); // map PSD

// 8. An array of objects of length N. Each object has key -> value pair, the key being "y" and the value is a random number
var dataf = d3.range(0,nfft-1).map(function(f) { return {"y": 0 } })

// create SVG objects
var svgf = svg_create(margin, width, height, fScale, pScale);

// add labels
svg_add_labels(svgf, margin, width, height, "Frequency ("+units_freq_+"Hz)", "Power Spectra Density (dB)");

// clip paths
svgf.append("clipPath").attr("id","clipf").append("rect").attr("width",width).attr("height",height);

// 9. Append the path, bind the data, and call the line generator
var pathf = svgf.append("path")
    .attr("clip-path","url(#clipf)")
    .datum(dataf)
    .attr("class", "stroke-med no-fill stroke-yellow")
    .attr("d", linef);

// generate power spectral density
function generate_psd(f,w,g,n) {
    // update generator
    generator.clear();
    // add signal with gain compensating for signal bandwidth
    generator.add_signal(f,w,g + 10*Math.log10(w));
	generator.add_signal(fc_int,bw_int,gn_int+10*Math.log10(bw_int)); // interference

    //generator.add_noise(n); // add random noise samples
    generator.generate(n); // generate with specific noise floor
    //console.log(psd);
    return d3.range(0,nfft-1).map(function(i) { return {"y": generator.psd[i] } })
}

function toggle() {
    if (running) { stop()    }
    else         { restart() }
}

// compute amount of interference in signal
function compute_interference()
{
    // compute boundaires
    let f_lower = fc     - 0.5*bw,     f_upper = fc     + 0.5*bw;
    let i_lower = fc_int - 0.5*bw_int, i_upper = fc_int + 0.5*bw_int;

    // check for no overlap
    if ((f_lower > i_upper || f_upper < i_lower)) 
	{ return 0; }

    // partial or full overlap, compensating gain for interference bandwidth
    let f0 = Math.max(i_lower, f_lower);
    let f1 = Math.min(i_upper, f_upper);
    return (f1-f0)*Math.pow(10.,gn_int/10.)/bw_int;
}

function adapt_freq_approx_half_band(){
    //let f_lower = fc     - alpha*bw,     f_upper = fc     + alpha*bw;
	delta = 0.1;
	mc = 11;
    let f_lower = fc     - 0.5*bw,     f_upper = fc     + 0.5*bw;

    let i_lower = fc_int - 0.5*bw_int, i_upper = fc_int + 0.5*bw_int;
	
		bw = f_limit - bw_int;	  		// Set signal bandwidth to maximum value that guarantees no overlap with interferer if the interferer hops to f = 0
										// Assuming that the interferer bandwidth is constant
		if (fc_int < 0) {				// If interferer is closer to the lower frequency limit then hop to the upper end of the band
			fc = f_limit - bw / 2;		// Hop to the upper end of the band
		}
		else {							// In this case the interferer is closer to the upper frequency limit
			fc = -f_limit + bw / 2;		// Hop to the lower end of the band
		}
	return 0
}

function adapt_freq_max_contiguous_bw(){

    //let f_lower = fc     - alpha*bw,     f_upper = fc     + alpha*bw;
	//delta = 0.1;
	//bw = 0.19;
	//fc = 0;
	mc = 11;
	delta = 0.08;

	let f_lower = fc     - 0.5*bw,     f_upper = fc     + 0.5*bw;

	let i_lower = fc_int - 0.5*bw_int, i_upper = fc_int + 0.5*bw_int;

		if (i_lower + f_limit < f_limit - i_upper){  					// if interferer is closer to lower frequency limit then upper unoccupied sub-band is larger
		fc = f_limit - (f_limit - i_upper) / 2;							// hop to center of upper unocuppied sub-band
		bw = f_limit - i_upper - 0.5 * bw_int -delta;							// set bandwidth to use entire upper unoccupied sub-band
	} else {															// in this case the lower unoccupied sub-band is larger
		fc = -f_limit + (i_lower + f_limit) / 2;						// hop to center of lower unoccupied sub-band
		bw = i_lower + f_limit - 0.5 * bw_int -delta; 							// set bandwidth to use entire lower unoccupied sub-band
	}
	return 0
}


function fixed_bw_modcod(){
    //let f_lower = fc     - alpha*bw,     f_upper = fc     + alpha*bw;
	delta = 0.1;
	//bw = 0.19;
    let f_lower = fc     - 0.5*bw,     f_upper = fc     + 0.5*bw;

    let i_lower = fc_int - 0.5*bw_int, i_upper = fc_int + 0.5*bw_int;
	
	
	fc = 0;				// Set center frequency to center of band
	bw = 2 * f_limit;	// Occupy entire band
	mc = 0;			// Select most robust (and slowest) modulation and coding rate combination
	
    // compute and display SNR
	//let I     = compute_interference();     // interference power (linear)
    //let N     = bw * Math.pow(10.,n0/10.);  // noise power (linear)
 
	//let SNRdB = 0;// gn - n0 - 10*Math.log10(bw);
    //let SINRdB= gn - 10*Math.log10(N+I);
    //let SINRdB1= gn - 10*Math.log10(N);

	//SNRdB = SINRdB;
	return 0; 
}

function adapt_gain(){
    //let f_lower = fc     - alpha*bw,     f_upper = fc     + alpha*bw;
	delta = 0.1;
	//bw = 0.19;
	//mc = 11;
	
    //let f_lower = fc     - 0.5*bw,     f_upper = fc     + 0.5*bw;

    //let i_lower = fc_int - 0.5*bw_int, i_upper = fc_int + 0.5*bw_int;	
	
    if (margin_dB > 0) 
	{
		gn = 2;
		mc = 9;
	}		
	

	return 0; 
}

function adapt_freq_bw(){
    //let f_lower = fc     - alpha*bw,     f_upper = fc     + alpha*bw;
	delta = 0.1;
	mc = 11;
	
    let f_lower = fc     - 0.5*bw,     f_upper = fc     + 0.5*bw;

    let i_lower = fc_int - 0.5*bw_int, i_upper = fc_int + 0.5*bw_int;
	
	
    if (!(f_lower > i_upper || f_upper < i_lower)) 
	{		alpha = 2;
		
		let ch1 = f_lower -i_lower;
		let ch2 = f_upper -i_upper;
		let ch3 = Math.abs(i_upper -f_lower);
		let ch4 = Math.abs(i_lower -f_upper);
		
		if ((ch2 > 0) && (ch1 >0)){
			if (f_lower < -f_limit) { fc =0; }
			if (f_upper >  f_limit) { fc = 0; }
			
			coin = (Math.floor(Math.random() * 2) == 0);
			if (coin){
				fc = fc  + ch3 + delta
				bw = bw_int
			}else{
				fc = fc  - ch3 - delta
				bw = bw_int
			}
			return 0
		}
		
		if ((ch2 > 0) && (ch1 <0)){
			if (f_lower < -f_limit) { fc =0; }
			if (f_upper >  f_limit) { fc = 0; }
			Math.max(Math.abs(ch3), Math.abs(ch4))
			ch5 = Math.abs(ch3) +  Math.abs(ch4);
			coin = (Math.floor(Math.random() * 2) == 0);
			if (coin){
				fc = fc  + ch5 + delta
				bw = bw_int

			}else{
				fc = fc  - ch5 - delta
				bw = bw_int

			}
 			return 0

		}
		if ((ch2 < 0) && (ch1 < 0)){
			if (f_lower < -f_limit) { fc =0; }
			if (f_upper >  f_limit) { fc = 0; }
			//fc = fc + ch4+ delta
			coin = (Math.floor(Math.random() * 2) == 0);
			if (coin){
				fc = fc  + ch4 + delta
				bw = bw_int

			}else{
				fc = fc  - ch4 - delta
				bw = bw_int

			}
			return 0

		}
		
		fc = 0;
		return 0;		
		//if (!((i_upper > f_lower)  || (i_lower > f_upper) ))
		//{
			//fc = 0;
		//}
		
		//bw = bw_int;
	}
	else
	{
	//alpha = 0.5
	}
	return 0; 
}

function adapt(){
    //let f_lower = fc     - alpha*bw,     f_upper = fc     + alpha*bw;
	delta = 0.1;
	//bw = 0.19;
	//mc = 11;
	
    let f_lower = fc     - 0.5*bw,     f_upper = fc     + 0.5*bw;

    let i_lower = fc_int - 0.5*bw_int, i_upper = fc_int + 0.5*bw_int;
	
	
    if (!(f_lower > i_upper || f_upper < i_lower)) 
	{		alpha = 2;
		
		let ch1 = f_lower -i_lower;
		let ch2 = f_upper -i_upper;
		let ch3 = Math.abs(i_upper -f_lower);
		let ch4 = Math.abs(i_lower -f_upper);
		
		if ((ch2 > 0) && (ch1 >0)){
			if (f_lower < -f_limit) { fc =0; }
			if (f_upper >  f_limit) { fc = 0; }
			
			coin = (Math.floor(Math.random() * 2) == 0);
			if (coin){
				fc = fc  + ch3 + delta
			}else{
				fc = fc  - ch3 - delta
			}
			return 0
		}
		
		if ((ch2 > 0) && (ch1 <0)){
			if (f_lower < -f_limit) { fc =0; }
			if (f_upper >  f_limit) { fc = 0; }
			Math.max(Math.abs(ch3), Math.abs(ch4))
			ch5 = Math.abs(ch3) +  Math.abs(ch4);
			coin = (Math.floor(Math.random() * 2) == 0);
			if (coin){
				fc = fc  + ch5 + delta
			}else{
				fc = fc  - ch5 - delta
			}
 			return 0

		}
		if ((ch2 < 0) && (ch1 < 0)){
			if (f_lower < -f_limit) { fc =0; }
			if (f_upper >  f_limit) { fc = 0; }
			//fc = fc + ch4+ delta
			coin = (Math.floor(Math.random() * 2) == 0);
			if (coin){
				fc = fc  + ch4 + delta
			}else{
				fc = fc  - ch4 - delta
			}
			return 0

		}
		
		fc = 0;
		return 0;		
		//if (!((i_upper > f_lower)  || (i_lower > f_upper) ))
		//{
			//fc = 0;
		//}
		
		//bw = bw_int;
	}
	else
	{
	//alpha = 0.5
	}
	return 0; 
}


function adapt_random(){
    //let f_lower = fc     - alpha*bw,     f_upper = fc     + alpha*bw;
	delta = 0.1;
	//bw = 0.19;
	//mc = 11;
	
    let f_lower = fc     - 0.5*bw,     f_upper = fc     + 0.5*bw;

    let i_lower = fc_int - 0.5*bw_int, i_upper = fc_int + 0.5*bw_int;	
	
    //if (!(f_lower > i_upper || f_upper < i_lower)) 
	//{
		fc = 0.97*(Math.random()-0.5)*(1-bw_int);update_plot();  
	//}		
	
    // compute and display SNR
	let I     = compute_interference();     // interference power (linear)
    let N     = bw * Math.pow(10.,n0/10.);  // noise power (linear)
 
	let SNRdB = 0;// gn - n0 - 10*Math.log10(bw);
    let SINRdB= gn - 10*Math.log10(N+I);
    let SINRdB1= gn - 10*Math.log10(N);

	SNRdB = SINRdB;
	return 0; 
}

//
// historical rate plot
// historical rate plot
//
var datar = d3.range(0,num_steps-1).map(function(f) { return {"y":1} })
var svgr = d3.select("body").append("svg")
    .attr("width",  width  + margin.left + margin.right)
    .attr("height", height + margin.top +  margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var tscale = d3.scaleLinear().domain([0, num_steps]).range([0, width]);
var rscale = d3.scaleLog   ().domain([100e3, 400e6]).range([height, 0]);
var liner = d3.line()
    .x(function(d, i) { return tscale(i);   })
    .y(function(d, i) { return rscale(d.y); });

svgr.append("defs").append("clipPath")
    .attr("id", "clipr")
  .append("rect")
    .attr("width", width)
    .attr("height", height);

	svgr.append("rect")
		.attr("width", "86.2%")
		.attr("height", "81%")
		.attr("fill", "black");
		
		
svgr.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(tscale));

var rtickvalues = [ 100e3, 400e3,1e6,2e6,4e6,10e6,20e6,40e6,100e6,200e6,400e6]
svgr.append("g")
    .attr("class", "y axis")
    .call(d3.axisLeft(rscale)
      .tickValues(rtickvalues)
      .tickFormat(function(d, i) {
        let [s,u] = scale_units(d);
        return d*s + u;
      }))

// grid lines
svgr.append("g").attr("class","grid").call(d3.axisBottom(tscale).tickFormat("").tickSize(height));
svgr.append("g").attr("class","grid").call(d3.axisLeft  (rscale).tickFormat("").tickSize(-width).tickValues(rtickvalues));

/*
svgr.append("g")
    .attr("clip-path", "url(#clip)")
  .append("path")
  .transition()
    .duration(dur)
    .ease(d3.easeLinear)
    .on("start", tick);
*/


	
svgr.append("text")
   .attr("transform","translate("+(width/2)+","+(height + 0.75*margin.bottom)+")")
   .attr("dy","-0.3em")
   .style("text-anchor","middle")
   		.attr("fill", "white")
   .text("Time Step")

// create y-axis label
svgr.append("text")
   .attr("transform","rotate(-90)")
   .attr("y", 0 - margin.left)
   .attr("x", 0 - (height/2))
   .attr("dy", "1em")
   .style("text-anchor","middle")
   		.attr("fill", "white")
   .text("Data Rate (bits/second)")

// 9. Append the path, bind the data, and call the line generator
var pathr = svgr.append("path")
    .attr("clip-path","url(#clipr)")
    .datum(datar)
    .attr("class", "stroke-med no-fill stroke-orange")
    .attr("d", liner);

//
// capacity plot
//




// channel capacity (b/s/Hz) given SNR in dB
function efficiency(snr) { return Math.log2(1.0 + Math.pow(10,snr/10)); }

// capacity curve
// (-10, 4 Mb/s, 0.1375 b/s/Hz), (40 dB, 382 Mb/s, 13.288 b/s/Hz)
var datac = d3.range(-10,40+0.01).map(function(d,i) { return {"x":d, "y":efficiency(d)} })

var svgc = d3.select("body").append("svg")
    .attr("width",  width  + margin.left + margin.right)
    .attr("height", height + margin.top +  margin.bottom)
    .attr("id", "svg-capacity")
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// create scale
var sscale = d3.scaleLinear().domain([-10,40]).range([0, width]); // snr (Eb/N0?)
var cscale = d3.scaleLog   ().domain([0.5, 8]).range([height, 0]); // capacity (b/s/Hz)
//.domain([schemes[0].rate, schemes[schemes.length-1].rate])

svgc.append("defs").append("clipPath")
    .attr("id", "clip")
  .append("rect")
    .attr("width", width)
    .attr("height", height);
	
		svgc.append("rect")
		.attr("width", "86.2%")
		.attr("height", "81%")
		.attr("fill", "black");
		

svgc.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(sscale));

//var yTickValues = [0.1,0.2,0.5,1,2,5,10,20]
var yTickValues = [];
schemes.forEach(function(d,i) { yTickValues.push(d.rate); });

svgc.append("g")
    .attr("class", "y axis")
    .call(d3.axisLeft(cscale)
      .tickValues(yTickValues)
        .tickFormat(function(d) { return d3.format(".2f")(d); } ))

// grid lines
svgc.append("g").attr("class","grid").call(d3.axisBottom(sscale).tickFormat("").tickSize(height));
svgc.append("g").attr("class","grid").call(d3.axisLeft  (cscale).tickFormat("").tickSize(-width).tickValues(yTickValues));

// create x-axis axis label
svgc.append("text")
   .attr("transform","translate("+(width/2)+","+(height + 0.75*margin.bottom)+")")
   .attr("dy","-0.3em")
   .style("text-anchor","middle")
   		.attr("fill", "white")
   .text("SNR (dB)")

// create y-axis label
svgc.append("text")
   .attr("transform","rotate(-90)")
   .attr("y", 0 - margin.left)
   .attr("x", 0 - (height/2))
   .attr("dy", "1em")
   .style("text-anchor","middle")
   		.attr("fill", "white")
   .text("Spectral Efficiency (bits/second/Hz)")

// clip paths
svgc.append("clipPath").attr("id","clipf").append("rect").attr("width",width).attr("height",height);

// line generator for capacity, mod/cod curves
var linec = d3.line()
    .x(function(d) { return sscale(d.x); })  // map SNR
    .y(function(d) { return cscale(d.y); }); // map capacity

// 9. Append the path, bind the data, and call the line generator
var pathc = svgc.append("path")
    .attr("clip-path","url(#clipf)")
    .datum(datac)
    .attr("class", "stroke-light no-fill stroke-green-o")
    .attr("d", linec);

// 9. Append the path, bind the data, and call the line generator
var datam = d3.range(schemes.length)
              .map(function(d,i) { return {"x":schemes[i].SNR, "y":schemes[i].rate} });
var pathc = svgc.append("path")
    .attr("clip-path","url(#clipf)")
    .datum(datam)
    .attr("class", "stroke-light no-fill stroke-green-o dashed")
    .attr("d", linec);

// add operating ponit
svgc.append('g')
    .selectAll("dot")
    .data( [{"x":0, "y":efficiency(0)}] )
    .enter()
    .append("circle")
      .attr("cx", function (d) { return sscale(d.x); } )
      .attr("cy", function (d) { return cscale(d.y); } )
      .attr("r", 5)
      .attr("class", "stroke-light stroke-green-o")
      .style("fill", "#66ff00");

function adjust_dwell(slow_, fast_){
	if (slow_ != null){
		adjust_dwell_time = 1.5
	}
	if (fast_ != null){
		adjust_dwell_time = 8
	}
}

// 'hop' interference around
function update_hop_rate(slow_, fast_)
{
	if (slow_ != null){
		rate = 0.2;
		uIndexHop = 1;
		hop_dwell_time = step_dwell_time*10 / rate;
	}
	if (fast_ != null){
		rate = 2
		uIndexHop = 2;

		hop_dwell_time = step_dwell_time*10 / rate;

	}
    //document.querySelector('#hr').value = d3.format(".2f")(rate) + " Hz";
}

function update_plot(freq,band,gain,modcod) {
    if (freq !=null) { fc = freq;  }
    if (band !=null) { bw = band;  }
    if (gain !=null) { gn = gain;  }
    if (modcod!=null){ mc = modcod;}
    //if (hop_rate!=null){ hr = hop_rate;}

	//adapt()

	let  f_lower = fc - 0.5*bw, f_upper = fc + 0.5*bw;
    //if (f_lower < -f_limit) { fc -= f_lower+f_limit; }
    //if (f_upper >  f_limit) { fc -= f_upper-f_limit; }

    document.querySelector('#fc').value = d3.format(".1f")((f0+fc*fs_)*scale_freq_) + " " + units_freq_ + "Hz";
    document.querySelector('#frequency').value = fc;

    document.querySelector('#bw').value = d3.format(".2f")(bw*fs_*scale_freq_) + " " + units_freq_ + "Hz";
    document.querySelector('#bandwidth').value = bw;

    //document.querySelector('#gn').value = d3.format(".2f")(gn) + " dB";
   // document.querySelector('#gain').value = gn;

	
    document.querySelector('#mc').value = schemes[mc].name + " (" + d3.format(".3f")(schemes[mc].rate) + " b/s/Hz)"
    document.querySelector('#modcod').value = mc;
	
	//if(document.querySelector('#slow').checked) {
	//adjust_dwell_time = 1.5;
	//}else if(document.querySelector('#fast').checked) {
	//adjust_dwell_time = 8;
	//} 


	
    // compute and display SNR
	let I     = compute_interference();     // interference power (linear)
    let N     = bw * Math.pow(10.,n0/10.);  // noise power (linear)
 
	let SNRdB = 0;// gn - n0 - 10*Math.log10(bw);
    let SINRdB= gn - 10*Math.log10(N+I);
	SNRdB = SINRdB;
	
    document.querySelector('#snr').value = d3.format(".2f")(SNRdB) + " dB";

    // compute and display spectral efficiency, capacity
    let R = efficiency(SNRdB);  // spectral efficiency (b/s/Hz)
    let C = fs * bw * R;        // capacity (b/s)
    var [scale_cap,units_cap] = scale_units(C,0.1);
    document.querySelector('#cap').value = d3.format(".1f")(C*scale_cap) + " " + units_cap + "b/s";
    document.querySelector('#eta').value = d3.format(".3f")(R) + " " + "b/s/Hz";

    // compute and display link margin
    margin_dB = SNRdB - schemes[mc].SNR;
    document.querySelector('#margin').value = d3.format(".2f")(margin_dB) + " dB";
    document.querySelector('#margin').style.color = margin_dB < 0 ? "red" : "white";

    // compute and display actual data rate
    valid = margin_dB >= 0;
    if (valid) {
        rate = schemes[mc].rate * bw * fs;
        var [scale_rate,units_rate] = scale_units(rate,0.1);
        let percent_capacity = 100 * rate / C;
        document.querySelector('#rate').value = d3.format(".1f")(rate*scale_rate) + " " + units_rate + "bps (" +
                                                d3.format(".1f")(percent_capacity) + "% capacity)";
        document.querySelector('#rate').style.color = "white";
    } else {
        rate = 0;
        document.querySelector('#rate').value = "0 bps";
        document.querySelector('#rate').style.color = "red";
    }

    // generate power spectral density, compensating for bandwidth
    dataf = generate_psd(fc,bw,gn,n0);
	
    pathf.datum(dataf).attr("d", linef);

    // update capacity value
    d3.selectAll("#svg-capacity circle")
      .data( [{"x":SNRdB, "y":R}] )
      .attr("cx", function(d) { return sscale(d.x); })
      .attr("cy", function(d) { return cscale(schemes[mc].rate); })
      .attr("class", valid ? "stroke-med stroke-green" : "stroke-med stroke-red")
}

// restart simulation
var counter=0, bits=0, outages=0, outages_survived = 0, runtime=60, step_dwell_time=50;
var num_steps = Math.round(runtime * 1000 / step_dwell_time);
hop_dwell_time = step_dwell_time;

function reset() {
    mc = Math.max(0,schemes.length - 3);
    [gn,bw] = gn_bw_profile(0);
    counter = num_steps;
    bits  = 0;
    outages = 0;
	outages_survived = 0;
	gn = 2;
    document.querySelector('#bits').value    = d3.format(",")(bits);
    document.querySelector('#outages').value = d3.format(",")(outages);
	document.querySelector('#outages_survived').value = d3.format(",")(outages_survived);
    document.querySelector('#timer').value   = d3.format(",")(counter);
	document.querySelector('#gain').value   = d3.format(".2f")(gn) + " dB";


	document.querySelector('#frequency_').value   =d3.format(".1f")((f0+fc*fs_)*scale_freq_) + " " + units_freq_ + "Hz";
	document.querySelector('#bw_').value  = d3.format(".2f")(bw*fs_*scale_freq_) + " " + units_freq_ + "Hz";
	//hop_interval();

	document.querySelector('#frequency_int').value   =d3.format(".1f")((f0+fc_int*fs_)*scale_freq_) + " " + units_freq_ + "Hz";
	document.querySelector('#bw_int').value  = d3.format(".2f")(bw_int*fs_*scale_freq_) + " " + units_freq_ + "Hz";
	
	document.querySelector('#temp1').value   = temp1;
	document.querySelector('#temp2').value   = temp2;
	document.querySelector('#temp3').value   = temp3;
	document.querySelector('#temp4').value   = temp4;
	document.querySelector('#temp5').value   = temp5;

	finished();
	//adapt_interval();

}

function restart() {
		//reset();

		if (!((uIndex == -1) )){
		
		if (!(counter > 0)){
		reset();
		datar = d3.range(0,num_steps-1).map(function(f) { return {"y":1} })
		}
		//path
		//svgr.selectAll("pathr").remove();

		//svgr.selectAll("liner").remove();
		//datar = [];
		//for (index = 0; index < datar.length; index++) { 
		//datar.push({"y":0});
		//datar.shift();
		//datar [index] = 0;
		//} 
		running = true;

		//step();
		console.log(uIndex)


		callback = new Function(document.querySelector('#userfunction').value);
		
		//let current = (uIndex == 3) ? {'frequency':fc, 'gain':gn, 'bandwidth':bw, 'modulation_index':mc}:
		 //{'gain':gn, 'bandwidth':bw, 'modulation_index':mc};;


 		let current = (uIndex == 5) ?  {'interfererfrequency':fc_int, 'interfererbandwidth':bw_int,'frequency':fc,  'gain':gn, 'bandwidth':bw, 'modulation_index':mc, 'temporary1':temp1,
		'temporary2':temp2,'temporary3':temp3,'temporary4':temp4,'temporary5':temp5
		}:  (uIndex == 4) ? {'interfererfrequency':fc_int, 'interfererbandwidth':bw_int,'frequency':fc,  'gain':gn, 'bandwidth':bw, 'modulation_index':mc}:
		(uIndex == 3) ? {'frequency':fc, 'gain':gn, 'bandwidth':bw, 'modulation_index':mc}:
		 {'gain':gn, 'bandwidth':bw, 'modulation_index':mc};;
		 
		 
		let uservals = callback(current);

		gn = uservals.gain;
		//gn_offset = uservals.gn_offset;
		// validate modulation/coding scheme
        mc = Math.max(0, Math.min(schemes.length-1, Math.round(uservals.modulation_index)));
        if (typeof mc != "number" || isNaN(mc)) { mc = 0; }

        // validate center frequency

        // validate bandwidth
        bw = Math.max(0.05, Math.min(0.95, uservals.bandwidth));
        if (typeof bw != "number" || isNaN(bw)) { bw = 0.1; }

        gn = Math.max(-2, Math.min(5, uservals.gain));
        if (typeof gn != "number" || isNaN(gn)) { gn = 1; }

		if (uIndex == 3){
			fc = Math.max(-0.5, Math.min(0.5, uservals.frequency));
			if (typeof fc != "number" || isNaN(fc)) { fc = 0; }		
		}

		if (uIndex == 4){
			fc = Math.max(-0.5, Math.min(0.5, uservals.frequency));
			if (typeof fc != "number" || isNaN(fc)) { fc = 0; }	
			
			fc_int = Math.max(-0.5, Math.min(0.5, uservals.interfererfrequency));
			if (typeof fc_int != "number" || isNaN(fc_int)) { fc_int = 0; }		
			
			bw_int = Math.max(-0.5, Math.min(0.5, uservals.interfererbandwidth));
			if (typeof bw_int != "number" || isNaN(bw_int)) { bw_int = 0; }		
		}	


		if (uIndex == 5){
			temp1 = Math.max(-0.5, Math.min(0.5, uservals.temporary1));
			temp1 = uservals.temporary1;
			if (typeof temp1 != "number" || isNaN(temp1)) { temp1 = 0; }	

			temp2 = Math.max(-0.5, Math.min(0.5, uservals.temporary2));
			temp2 = uservals.temporary2;
			if (typeof temp2 != "number" || isNaN(temp2)) { temp2 = 0; }

			temp3 = Math.max(-0.5, Math.min(0.5, uservals.temporary3));
			temp3 = uservals.temporary3;
			if (typeof temp3 != "number" || isNaN(temp3)) { temp3 = 0; }
			
			temp4 = Math.max(-0.5, Math.min(0.5, uservals.temporary4));
			temp4 = uservals.temporary4;
			if (typeof temp4 != "number" || isNaN(temp4)) { temp4 = 0; }
			
			temp5 = Math.max(-0.5, Math.min(0.5, uservals.temporary5));
			temp5 = uservals.temporary5;
			if (typeof temp5 != "number" || isNaN(temp5)) { temp5 = 0; }
			

			fc = Math.max(-0.5, Math.min(0.5, uservals.frequency));
			if (typeof fc != "number" || isNaN(fc)) { fc = 0; }	
			
			fc_int = Math.max(-0.5, Math.min(0.5, uservals.interfererfrequency));
			if (typeof fc_int != "number" || isNaN(fc_int)) { fc_int = 0; }		
			
			bw_int = Math.max(-0.5, Math.min(0.5, uservals.interfererbandwidth));
			if (typeof bw_int != "number" || isNaN(bw_int)) { bw_int = 0; }		
		}	
		//string1 = gn.toString();
		//string2 = bw.toString();
		//string3 = mc.toString();

		//u_ = string.concat("return {'gn':", string1, ", 'bw':", string2, ", 'mc':",  string3, "};")
		// Error de
		var dictU_ = {
		  'gain': gn,
		  'bandwidth': bw,
		  'modulation_index': mc
		};
		//u_ = String(dictU_);
		//u_ = {"return ", dictU_}
		u_ = "return " + JSON.stringify(dictU_);
		u_1 = "return {'gain': " + JSON.stringify(gn) +  "1, 'bandwidth': " + JSON.stringify(bw) + " , 'modulation_index': " + JSON.stringify(mc) + " -1}\n";
		
		//u_a3  = "// check current link margin and adjust scheme appropriately\n";
		//u_a3 += "//gn_offset = 1"
		//u_a3 += ";\n"
		//u_a3 += "//mc_offset = 1;\n\n"
        //u_a3 += "if (margin_dB > 0) \n{"
		//u_a3 += u_1
		//u_a3 += "}\n";
        //u_a3 += "else \n{ "
		//u_a3 += u_1
		//u_a3 += "}\n";
		
        //u  = "// check current link margin and adjust scheme appropriately\n";
		//u += "//gn_offset = "
		//u +=  JSON.stringify(gn_offset)
		//u += ";\n"
		//u += "//mc_offset = 1;\n\n"
        //u += "if (margin_dB > 0) \n{ return {'gain':gn, 'bandwidth':bw, 'modulation_index':mc}; }\n";
        //u += "else \n{ return {'gain':gn + 1, 'bandwidth':bw, 'modulation_index':mc - 1}; }\n";
		
		if (uIndex == 3){
		//	document.querySelector('#userfunction').value = u_a3; 
		}
		else{
		//	document.querySelector('#userfunction').value = u_;
		}
		console.log(u_)
		//u_ = string.concat("return ", u_)

		
		step_interval();
		hop_interval();
		adapt_interval();
		running = true;
		
		document.querySelector('#restart').value = "stop"
		document.querySelector('#userfunction').disabled = true;

		//if (checkSensing == 1){
		//	document.querySelector('#slow').checked = true;
		//	document.querySelector('#hr_slow').checked = true;
		//	checkSensing = 0
		//}
	}
}

function stop() {
    console.log("stop!");
    running = false;
    document.querySelector('#restart').value = 'start';
    document.querySelector('#userfunction').disabled = false;
}

async function step_interval() {
    await new Promise((res, req) => { setTimeout(res, step_dwell_time) });
    if ((counter > 0) && (running == true)) {
	    step();
		//step();
        //let current = {'gain':gn, 'bandwidth':bw, 'modulation_index':mc};
		

		//let current = (uIndex == 3) ? {'frequency':fc, 'gain':gn, 'bandwidth':bw, 'modulation_index':mc}:
		// {'gain':gn, 'bandwidth':bw, 'modulation_index':mc};;
		 
 		let current = (uIndex == 5) ?  {'interfererfrequency':fc_int, 'interfererbandwidth':bw_int,'frequency':fc,  'gain':gn, 'bandwidth':bw, 'modulation_index':mc, 'temporary1':temp1,
		'temporary2':temp2,'temporary3':temp3,'temporary4':temp4,'temporary5':temp5
		}:  (uIndex == 4) ? {'interfererfrequency':fc_int, 'interfererbandwidth':bw_int,'frequency':fc,  'gain':gn, 'bandwidth':bw, 'modulation_index':mc}:
		(uIndex == 3) ? {'frequency':fc, 'gain':gn, 'bandwidth':bw, 'modulation_index':mc}:
		 {'gain':gn, 'bandwidth':bw, 'modulation_index':mc};;
		 
		 
		 
		callback = new Function(document.querySelector('#userfunction').value);


		let uservals = callback(current);

		gn = uservals.gain;
		gn_offset = uservals.gn_offset;
		console.log(gn_offset);

		// validate modulation/coding scheme
        mc = Math.max(0, Math.min(schemes.length-1, Math.round(uservals.modulation_index)));
        if (typeof mc != "number" || isNaN(mc)) { mc = 0; }

        // validate center frequency

        // validate bandwidth
        bw = Math.max(0.05, Math.min(0.95, uservals.bandwidth));
        if (typeof bw != "number" || isNaN(bw)) { bw = 0.1; }

        gn = Math.max(-2, Math.min(5, uservals.gain));
        if (typeof gn != "number" || isNaN(gn)) { gn = 1; }
		
		if (uIndex == 3){
			fc = Math.max(-0.5, Math.min(0.5, uservals.frequency));
			if (typeof fc != "number" || isNaN(fc)) { fc = 0; }		
		}

		if (uIndex == 4){
			fc = Math.max(-0.5, Math.min(0.5, uservals.frequency));
			if (typeof fc != "number" || isNaN(fc)) { fc = 0; }	
			
			fc_int = Math.max(-0.5, Math.min(0.5, uservals.interfererfrequency));
			if (typeof fc_int != "number" || isNaN(fc_int)) { fc_int = 0; }		
			
			bw_int = Math.max(-0.5, Math.min(0.5, uservals.interfererbandwidth));
			if (typeof bw_int != "number" || isNaN(bw_int)) { bw_int = 0; }		
		}

		if (uIndex == 5){
			temp1 = Math.max(-0.5, Math.min(0.5, uservals.temporary1));
			temp1 = uservals.temporary1;
			if (typeof temp1 != "number" || isNaN(temp1)) { temp1 = 0; }	

			temp2 = Math.max(-0.5, Math.min(0.5, uservals.temporary2));
			temp2 = uservals.temporary2;
			if (typeof temp2 != "number" || isNaN(temp2)) { temp2 = 0; }

			temp3 = Math.max(-0.5, Math.min(0.5, uservals.temporary3));
			temp3 = uservals.temporary3;
			if (typeof temp3 != "number" || isNaN(temp3)) { temp3 = 0; }
			
			temp4 = Math.max(-0.5, Math.min(0.5, uservals.temporary4));
			temp4 = uservals.temporary4;
			if (typeof temp4 != "number" || isNaN(temp4)) { temp4 = 0; }
			
			temp5 = Math.max(-0.5, Math.min(0.5, uservals.temporary5));
			temp5 = uservals.temporary5;
			if (typeof temp5 != "number" || isNaN(temp5)) { temp5 = 0; }
			

			fc = Math.max(-0.5, Math.min(0.5, uservals.frequency));
			if (typeof fc != "number" || isNaN(fc)) { fc = 0; }	
			
			fc_int = Math.max(-0.5, Math.min(0.5, uservals.interfererfrequency));
			if (typeof fc_int != "number" || isNaN(fc_int)) { fc_int = 0; }		
			
			bw_int = Math.max(-0.5, Math.min(0.5, uservals.interfererbandwidth));
			if (typeof bw_int != "number" || isNaN(bw_int)) { bw_int = 0; }		
		}	
		document.querySelector('#temp1').value   = temp1;
		document.querySelector('#temp2').value   = temp2;
		document.querySelector('#temp3').value   = temp3;
		document.querySelector('#temp4').value   = temp4;
		document.querySelector('#temp5').value   = temp5;
		step_interval();
    } else {

        finished() ;
    }
}


// 'hop' interference around

//function update_hop_rate(rate)
//{
//    hop_dwell_time = step_dwell_time*10 / rate;
//    document.querySelector('#hr').value = d3.format(".2f")(rate) + " Hz";
//}
update_hop_rate(0.2)
function hop() { 
    // compute boundaires
	if ((counter <= 0) || (running == false))
	{ return 0;}
	
	
    let f_lower = fc     - 0.5*bw,     f_upper = fc     + 0.5*bw;
    let i_lower = fc_int - 0.5*bw_int, i_upper = fc_int + 0.5*bw_int;

    // check for no overlap
//    if (!((f_lower > i_upper || f_upper < i_lower))) 
//		{fc_int = fc_int; return 0; }
	
	if (!(uIndex == 4)){
		fc_int = 0.97*(Math.random()-0.5)*(1-bw_int);update_plot();    
	}
    // compute and display SNR
	let I     = compute_interference();     // interference power (linear)
    let N     = bw * Math.pow(10.,n0/10.);  // noise power (linear)
 
	let SNRdB = 0;// gn - n0 - 10*Math.log10(bw);
    let SINRdB= gn - 10*Math.log10(N+I);
    let SINRdB1= gn - 10*Math.log10(N);

	SNRdB = SINRdB;
	
    // compute and display link margin
    let margin_dB = SNRdB - schemes[mc].SNR;
    let margin_dB1 = SINRdB1 - schemes[mc].SNR;
	
    valid2 = margin_dB >= 0;
    valid2_1 = margin_dB1 < 0;
	
	if (!(valid2_1)){
		hop_check = 1;
	}
	//fc_saved = fc_int;
}
	

async function hop_interval() {
  await new Promise((res, req) => { setTimeout(res, hop_dwell_time) })
  hop()
  hop_interval() 
}

async function adapt_interval() {
  await new Promise((res, req) => { setTimeout(res, hop_dwell_time/adjust_dwell_time) })
  
  if (uIndex == 0){
        fixed_bw_modcod();
	}
	else if (uIndex == 1) {
        adapt_random();
    }
	else if (uIndex == 2) {
 		adapt();
    }
	else if (uIndex == 3) {
        //adapt_freq_approx_half_band();
		//adapt_random();
		///bw = 0.35;
		adapt_gain();
	}
	else if (uIndex == 4) {
		adapt_gain();		
		//adapt_freq_max_contiguous_bw();
    }
	else if (uIndex == 5) {
		adapt_gain();		
		//adapt_freq_max_contiguous_bw();
    }
	if ((counter > 0) && (running == true)) {
		update_plot()
		adapt_interval() 
	}
}

function adapt_freq_max_contiguous_bw(){

    //let f_lower = fc     - alpha*bw,     f_upper = fc     + alpha*bw;
	//delta = 0.1;
	//bw = 0.19;
	//fc = 0;
	mc = 11;
	delta = 0.08;

	let f_lower = fc     - 0.5*bw,     f_upper = fc     + 0.5*bw;

	let i_lower = fc_int - 0.5*bw_int, i_upper = fc_int + 0.5*bw_int;

		if (i_lower + f_limit < f_limit - i_upper){  					// if interferer is closer to lower frequency limit then upper unoccupied sub-band is larger
		fc = f_limit - (f_limit - i_upper) / 2;							// hop to center of upper unocuppied sub-band
		bw = f_limit - i_upper - 0.5 * bw_int -delta;							// set bandwidth to use entire upper unoccupied sub-band
	} else {															// in this case the lower unoccupied sub-band is larger
		fc = -f_limit + (i_lower + f_limit) / 2;						// hop to center of lower unoccupied sub-band
		bw = i_lower + f_limit - 0.5 * bw_int -delta; 							// set bandwidth to use entire lower unoccupied sub-band
	}
	return 0
}
// integrate
function accumulate_rate() { bits += rate; rate_avg += rate; cap_avg += cap; update_count += 1; }
//async function accumulate_interval() {
//  await new Promise((res, req) => { setTimeout(res, 50) })
//  accumulate_rate()
//  accumulate_interval()
//}
//accumulate_interval();


//time, gain, and bandwidth profiles
function gn_bw_profile(i) {
    let t = i * step_dwell_time * 1e-3;
    let gain = -5 + 10*Math.log10(0.001 + (0.5 + 0.5*Math.cos(2*Math.PI*0.04*t + 0.7))) *
           Math.exp(-0.05*t);
    let bandwidth = (0.1 + 0.8*(0.5 + 0.5*Math.cos(2*Math.PI*0.07*t + 1.5))) *
            Math.exp(-0.015*t);
    return [gn,bw];
}

function step() {
    // gain and bandwidth profiles
    [gn,bw] = gn_bw_profile(num_steps - counter);
	if (counter>0){
    counter -= 1;
	}
    update_plot();
	
    // update historical plot
    datar.push({"y":Math.max(rate,1)});
    datar.shift();
    pathr.datum(datar).attr("d", liner);
    bits += Math.round(rate * step_dwell_time * 1e-3);
    outages += valid ? 0 : 1;
	
    let f_lower = fc     - 0.5*bw,     f_upper = fc     + 0.5*bw;
    let i_lower = fc_int - 0.5*bw_int, i_upper = fc_int + 0.5*bw_int;

    // check for  overlap
    if (((f_lower > i_upper || f_upper < i_lower))) 
		{fc_saved = fc_int }

	
	if (valid2){
		outages_survived += 0;
	}
	else{
		if ((fc_saved == fc_int)&& (hop_check == 1)){
			outages_survived += 1;
		}
	}
    document.querySelector('#bits').value    = d3.format(",")(bits);
    document.querySelector('#outages').value = d3.format(",")(outages);
	document.querySelector('#outages_survived').value = d3.format(",")(outages_survived);
    document.querySelector('#timer').value   = d3.format(",")(counter);
	document.querySelector('#gain').value   = d3.format(".2f")(gn) + " dB";

	document.querySelector('#frequency_').value   = d3.format(".1f")((f0+fc*fs_)*scale_freq_) + " " + units_freq_ + "Hz";
	document.querySelector('#bw_').value  = d3.format(".2f")(bw*fs_*scale_freq_) + " " + units_freq_ + "Hz";

	document.querySelector('#frequency_int').value   =d3.format(".1f")((f0+fc_int*fs_)*scale_freq_) + " " + units_freq_ + "Hz";
	document.querySelector('#bw_int').value  = d3.format(".2f")(bw_int*fs_*scale_freq_) + " " + units_freq_ + "Hz";
	
	document.querySelector('#temp1').value   = temp1;
	document.querySelector('#temp2').value   = temp2;
	document.querySelector('#temp3').value   = temp3;
	document.querySelector('#temp4').value   = temp4;
	document.querySelector('#temp5').value   = temp5;
}

function populateCallback() {
    let selection = document.getElementById("strategy").value;
    //let u = -1;
	//let u = 'return 0;'
	//	u  = 'bw = 0.19\n';
    //    u += 'return bw';
    let u = "return {'gain':0, 'bandwidth':0.19, 'modulation_index':4};";

    switch (selection) {
    case 'default': uIndex = -1; break;	
    case 'a0': uIndex = 0; break;
    case 'a1': 
		uIndex = 1; 
		u = "return {'gain':2, 'bandwidth':0.25, 'modulation_index':11};";
		break;
    case 'a2': 
	uIndex = 2;
	u = "return {'gain':2, 'bandwidth':0.1, 'modulation_index':11};";
	break;
    case 'a3': 
		uIndex = 3; 
		//var dictU_ = {
		//  'gn': gn,
		//  'bw': bw,
		//  'mc': mc
		//};
		//u_ = String(dictU_);
		//u_ = {"return ", dictU_}
		//u_ = "return " + JSON.stringify(dictU_);
		//console.log(u_)
		//u_ = string.concat("return ", u_)

		//document.querySelector('#userfunction').value = u_;
        u  = "// check current link margin and adjust scheme appropriately\n";
		u += "//gn_offset = "
		u +=  JSON.stringify(gn_offset)
		u += ";\n"
		u += "//mc_offset = 1;\n\n"
        u += "if (margin_dB > 0) \n{ return {'frequency': fc, 'gain':gn, 'bandwidth':bw, 'modulation_index':mc}; }\n";
        u += "else \n{ return {'frequency': fc, 'gain':gn + 1, 'bandwidth':bw, 'modulation_index':mc - 1}; }\n";
		u_a3 = u;
		break;	
	case 'a4':
		uIndex = 4; 
		//var dictU_ = {
		//  'gn': gn,
		//  'bw': bw,
		//  'mc': mc
		//};
		//u_ = String(dictU_);
		//u_ = {"return ", dictU_}
		//u_ = "return " + JSON.stringify(dictU_);
		//console.log(u_)
		//u_ = string.concat("return ", u_)

		//document.querySelector('#userfunction').value = u_;
        u  = "// check current link margin and adjust scheme appropriately\n";
		u += "gn_temp = 0.0"
		u += ";\n"
		u += "//mc_offset = 1;\n\n"
        u += "if (margin_dB > 0) \n{ return {'interfererfrequency':fc_int, 'interfererbandwidth':bw_int,'frequency': fc, 'gain':gn , 'bandwidth':bw + gn_temp, 'modulation_index':mc}; }\n";
        u += "else \n{ return {'interfererfrequency':fc_int, 'interfererbandwidth':bw_int,'frequency': fc, 'gain':gn + 1, 'bandwidth':bw, 'modulation_index':mc - 1}; }\n";
		u_a3 = u;
		break;
		
	case 'a5':
		uIndex = 5; 
		//var dictU_ = {
		//  'gn': gn,
		//  'bw': bw,
		//  'mc': mc
		//};
		//u_ = String(dictU_);
		//u_ = {"return ", dictU_}
		//u_ = "return " + JSON.stringify(dictU_);
		//console.log(u_)
		//u_ = string.concat("return ", u_)

		//document.querySelector('#userfunction').value = u_;
        u  = "// check current link margin and adjust scheme appropriately;\n"
		u += "let delta = 0.04; \n"
		u += "let f_lower = fc     - 0.5*bw,     f_upper = fc     + 0.5*bw; \n"
		u += "let i_lower = fc_int - 0.5*bw_int, i_upper = fc_int + 0.5*bw_int; \n;"
		u += "if (i_lower + f_limit < f_limit - i_upper){  \n"
		u += "fc = f_limit - (f_limit - i_upper) / 2;	 \n"
		u += "bw = f_limit - i_upper - 0.5 * bw_int -delta;}\n"
		u += " \n"
		u += "else {\n"
		u += "fc = -f_limit + (i_lower + f_limit) / 2;\n"
		u += "bw =  i_lower + f_limit - 0.5 * bw_int- delta;"
		u += "}\n\n\n"
		u += "if (margin_dB > 0) \n{ return {'interfererfrequency':fc_int, 'interfererbandwidth':bw_int,'frequency': fc, 'gain':gn, 'bandwidth':bw, 'modulation_index':mc , "
		u += " 'temporary1':temp1,'temporary2':temp2,'temporary3':temp3,'temporary4':temp4,'temporary5':temp5"
		u += "}; }\n";
        u += "else \n{ return {'interfererfrequency':fc_int, 'interfererbandwidth':bw_int,'frequency': fc, 'gain':gn + 1, 'bandwidth':bw, 'modulation_index':mc - 1,"
		u += "'temporary1':temp1,'temporary2':temp2,'temporary3':temp3,'temporary4':temp4,'temporary5':temp5"
		u += "}; }\n";
		u_a3 = u;
		break;
		default:
		//u  = 'bw = 0.19\n';
        //u += 'return bw';
        return;
    }
    document.querySelector('#userfunction').value = u;
}

function finished() {
	update_hop_rate(0.2)

    document.querySelector('#restart').value = "start" ;
    document.querySelector('#bits').style.color = "#008040";
    document.querySelector('#outages').style.color = outages > 0 ? "#800000" : "#008040";
}

// set initial values and replot
reset();
update_plot();

</script>
</html>

