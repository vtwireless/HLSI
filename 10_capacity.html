<!DOCTYPE html>
<!-- 
To Do: Replace text-based status display with bar graph that includes text labels, 
numeric values, and average or cumulative metrics for the ongoing or most recent 
simulation interval 
-->
<html lang="en-US" style="display: flex;">
<head>
  <title>HLSI Ex 10</title>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width"/>
  <link rel="stylesheet" type="text/css" media="all" href="base.css">
  <link rel=stylesheet type=text/css href=sidebar.css />
</head>

<body style="margin:0;">
  <!-- <h2>Exercise 10 - Information Capacity</h2>
  <p><a href="index.html">[exercises]</a></p> -->

  <section class="banner" style="position: fixed; z-index: 11; background: rgba(0,0,0,0.85)">
    <label for="menu-control" class="hamburger">
      <i class="hamburger__icon"></i>
      <i class="hamburger__icon"></i>
      <i class="hamburger__icon"></i>
    </label>
    
    <input type="checkbox" id="menu-control" class="menu-control">
    
    <aside class="sidebar" style="z-index: 10;">
      
      <nav class="sidebar__menu">
        <a href="01_bw.html"><b>1</b> Bandwidth</a>
        <a href="02_freq.html"><b>2</b> Frequency</a>
        <a href="03_gn.html"><b>3</b> Gain</a>
        <a href="04_freq_bw_gn.html"><b>4</b> Frequency, Bandwidth, and Gain</a>
        <a href="05_capacity.html"><b>5</b> Information Capacity</a>
        <a href="06_interference.html"><b>6</b> Interference and Information Capacity</a>
        <a href="07_capacity.html"><b>7</b> Information Capacity</a>
        <a href="08_capacity.html"><b>8</b> Information Capacity</a>
        <a href="09_capacity.html"><b>9</b> Information Capacity</a>
        <a href="10_capacity.html" class="selected"><b>10</b> Information Capacity</a>
        <a href="11_pathloss.html"><b>11</b> Path Loss</a>
        <a href="12_pathloss_interference.html"><b>12</b> Path Loss with Interference</a>
        <a href="13_manual_avoidance.html"><b>13</b> Manual Interferer Avoidance</a>
        <a href="" onclick="alert('Exercise 14: reserved for future use')"><b>14</b> SAS (Spectrum Access System)</a>
        <a href="15_rule_based_avoidance.html"><b>15</b> Rule Based Interferer Avoidance</a>
        <a href="16_programmable_avoidance.html"><b>16</b> Programmable Interferer Avoidance</a>
        <a href="17_machine_learning_avoidance.html"><b>17</b> Machine Learning Interferer Avoidance</a>
        <a href="18_machine_learning_time_based_avoidance.html"><b>18</b> Machine Learning With Periodic Interferer Avoidance</a>
        <a href="19_rf_front_end_spectrum_sharing.html"><b>19</b> RF Front End Spectrum Sharing</a>
        <a href="20_rf_front_end_spectrum_sharing.html"><b>20</b> Programmable RF Front End Spectrum Sharing</a>
        <a href="21_rf_front_end_spectrum_sharing_with_interferer.html"><b>21</b> RF Front End Spectrum Sharing with Interferer</a>
        <a href="22_rf_front_end_spectrum_sharing_with_interferer.html"><b>22</b> Programmable Spectrum Sharing with Interferer</a>
        <a href="23_rf_front_end_spectrum_sharing_sliders_programmable.html"><b>23</b> RFFE Spectrum Sharing - Manual and Programmable</a>
      </nav>
      
      <label for="menu-control" class="sidebar__close"></label>
      
      
    </aside>
    
    <div style="margin-left: 6%; font-size: 1.3rem; margin-top: 0.3%; font-family: sans-serif; order: 1; width: inherit;"><span style="color: #ddd;">Exercise 10</span> Information Capacity, Data Rate, and Spectral Efficiency in Fading Channel with Programmable Automatic MCS Adaptation</div>
    <div style="order: 2; margin-left: auto; margin-right: 2%; display: flex;">
      <span style="font-size: 250%; font-family: monospace; letter-spacing: 2px; margin-left: auto; margin-right: 5px; color: #e6d9ba;"></span>
      <div style="width: 20%;">
        <img style="width: 100%;" src="images/wireless-logo.png">
      </div>
    </div>   
  </section>
  
  <div class="content-section" id="slider_1_parent" style="margin-left: 1%; margin-top:8%;">
    <p><label for="userfunction">
      Fill out a function to return the index of modulation/coding scheme
      selection based on SNR, link margin, etc. here
      (valid return values are integers in the range 0 through 11):  </label></p>
  <p><tt>function callback(modcod,current,SNR,lmargin)  {</tt></p>
	      <div class ="container">
  <div class = "fixed">
  <p><textarea id="userfunction" name="userfunction" rows="18" cols="90" 
      maxlength=2048 autofocus=true style="color:white;font: 1em monospace;"
      placeholder="return 0;">return 0;</textarea></p>
	  </div>
	  
	  	  <div class="flex-item">

<table style="width:100%">
  <tr>
    <th>Variable Name</th>
    <th>Meaning</th>
  </tr>
    <tr>
    <td>modcod</td>
    <td> Modulation and Coding Array of Signal </td>
  </tr>
    <tr>
    <td>current</td>
    <td>Modulation and Coding Index of Signal </td>
  </tr>
      <tr>
    <td>SNR</td>
    <td>Signal to noise ratio </td>
  </tr>
    <tr>
    <td>lmargin</td>
    <td>Link margin</td>
  </tr>
</table>
</div>

	  </div>
  <p><tt>}</tt></p>
  
  <p><input type="submit" id="toggle" value="Go!" onclick="toggle()">&nbsp;
  <label for="strategy" hidden>Select pre-configured strategy:</label>
  <select id="strategy" onchange="populateCallback()">
    <option value="" selected disabled hidden>Select pre-configured strategy...</option>
    <option value="a0">Fixed modulation/coding scheme</option>
    <option value="a1">Random selection</option>
    <option value="a2">Check if link is closed</option>
    <option value="a3">Check link margin</option>
    <option value="a4">Find best scheme</option>
  </select>
  </p>
  <p>
    <label for="signal_to_noise_ratio">SNR:       </label><output for="signal_to_noise_ratio" id="snr"    class="text-bold"></output>,
    <label for="information_capacity">Capacity:   </label><output for="information_capacity"  id="cap"    class="text-bold"></output>,
    <label for="spectral_efficiency">Spect. Eff.: </label><output for="spectral_efficiency"   id="eta"    class="text-bold"></output>
    <label for="link_margin">Margin:              </label><output for="link_margin"           id="margin" class="text-bold"></output>,
    <label for="actual_rate">Actual Rate:         </label><output for="actual_rate"           id="rate"   class="text-bold"></output>
  </p>
  <p>
    <label for="time_left"> Time Left:  </label><output for="time_left"  id="timer"   class="text-bold"></output>,
    <label for="outages">   Outages:    </label><output for="outages"    id="outages" class="text-bold"></output>,
    <label for="total_bits">Total Bits: </label><output for="total_bits" id="bits"    class="text-bold"></output>
  </p>
  </div>


</body>

<!-- Load in the javascript libraries -->
<script src="d3.v5.min.js"></script>
<script src="fft.js"></script>
<script src="support.js"></script>
<script>

// 2. Use the margin convention practice
var margin = {top: 10, right: 50, bottom: 50, left: 50}
  , width  = 720 - margin.left - margin.right  // Use the window's width
  , height = 320 - margin.top - margin.bottom; // Use the window's height

// options
var fs = 40e6, f0 = 1800e6;     // sample rate, center frequency
var bw = 0.2, fc = 0.0, gn = -20, mc = 0, n0 = -30,
    snr = 0, rate = 0, lmargin = 0, valid = false;
var nfft = 2048, generator = new siggen(nfft);
generator.m    = 40;  // set filter semi-length
generator.beta = 1.5; // set filter window exponent (smaller shows more side-lobes)
var schemes = [
    {'rate':0.50000, 'SNR': 3.979, 'name':'r1/2 BPSK'},
    {'rate':0.66667, 'SNR': 5.703, 'name':'r2/3 BPSK'},
    {'rate':1.00000, 'SNR': 7.109, 'name':'r1/2 QPSK'},
    {'rate':1.33333, 'SNR': 8.782, 'name':'r2/3 QPSK'},
    {'rate':1.77778, 'SNR':10.202, 'name':'r8/9 QPSK'},
    {'rate':2.66667, 'SNR':15.036, 'name':'r2/3 16-QAM'},
    {'rate':3.55556, 'SNR':16.747, 'name':'r8/9 16-QAM'},
    {'rate':4.44444, 'SNR':20.970, 'name':'r8/9 32-QAM'},
    {'rate':5.33333, 'SNR':22.920, 'name':'r8/9 64-QAM'},
    {'rate':6.22222, 'SNR':26.797, 'name':'r8/9 128-QAM'},
    {'rate':7.11111, 'SNR':28.570, 'name':'r8/9 256-QAM'},
    {'rate':8.00000, 'SNR':31.050, 'name':'uncoded 256-QAM'}]
// simulation properties
var counter=0, bits=0, outages=0, runtime=30, step_dwell_time=50;
var num_steps = Math.round(runtime * 1000 / step_dwell_time);

var running = false;

// determine scale/units
var [scale_freq,units_freq] = scale_units(f0+fs/2,0.1);
var fScale = d3.scaleLinear().domain([(f0-0.5*fs)*scale_freq, (f0+0.5*fs)*scale_freq]).range([0, width]);
var pScale = d3.scaleLinear().domain([-35, 15]).range([height, 0]);

// d3's line generator
var linef = d3.line()
    .x(function(d, i) { return fScale((f0+(i/nfft-0.5)*fs)*scale_freq); })  // map frequency
    .y(function(d)    { return pScale(d.y);        }); // map PSD

// 8. An array of objects of length N. Each object has key -> value pair, the key being "y" and the value is a random number
var dataf = d3.range(0,nfft-1).map(function(f) { return {"y": 0 } })

// create SVG objects
var svgf = svg_create(margin, width, height, fScale, pScale);

// add labels
svg_add_labels(svgf, margin, width, height, "Frequency ("+units_freq+"Hz)", "Power Spectral Density (dB)");

// clip paths
svgf.append("clipPath").attr("id","clipf").append("rect").attr("width",width).attr("height",height);

// 9. Append the path, bind the data, and call the line generator
var pathf = svgf.append("path")
    .attr("clip-path","url(#clipf)")
    .datum(dataf)
    .attr("class", "stroke-med no-fill stroke-yellow")
    .attr("d", linef);

// generate power spectral density
function generate_psd(f,w,g,n) {
    // update generator
    generator.clear();
    // add signal with gain compensating for signal bandwidth
    generator.add_signal(f,w,g + 10*Math.log10(w));
    //generator.add_noise(n); // add random noise samples
    generator.generate(n); // generate with specific noise floor
    //console.log(psd);
    return d3.range(0,nfft-1).map(function(i) { return {"y": generator.psd[i] } })
}

//
// historical rate plot
//
var datar = d3.range(0,num_steps-1).map(function(f) { return {"y":1} })
var svgr = d3.select("body").append("svg")
    .attr("width",  width  + margin.left + margin.right)
    .attr("height", height + margin.top +  margin.bottom)
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var tscale = d3.scaleLinear().domain([0, num_steps]).range([0, width]);
var rscale = d3.scaleLog   ().domain([100e3, 400e6]).range([height, 0]);
var liner = d3.line()
    .x(function(d, i) { return tscale(i);   })
    .y(function(d, i) { return rscale(d.y); });

svgr.append("defs").append("clipPath")
    .attr("id", "clipr")
  .append("rect")
    .attr("width", width)
    .attr("height", height);

	svgr.append("rect")
		.attr("width", "86.2%")
		.attr("height", "81%")
		.attr("fill", "black");
		
		
svgr.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(tscale));

var rtickvalues = [ 100e3, 400e3,1e6,2e6,4e6,10e6,20e6,40e6,100e6,200e6,400e6]
svgr.append("g")
    .attr("class", "y axis")
    .call(d3.axisLeft(rscale)
      .tickValues(rtickvalues)
      .tickFormat(function(d, i) {
        let [s,u] = scale_units(d);
        return d*s + u;
      }))

// grid lines
svgr.append("g").attr("class","grid").call(d3.axisBottom(tscale).tickFormat("").tickSize(height));
svgr.append("g").attr("class","grid").call(d3.axisLeft  (rscale).tickFormat("").tickSize(-width).tickValues(rtickvalues));

/*
svgr.append("g")
    .attr("clip-path", "url(#clip)")
  .append("path")
  .transition()
    .duration(dur)
    .ease(d3.easeLinear)
    .on("start", tick);
*/

// create x-axis axis label
svgr.append("text")
   .attr("transform","translate("+(width/2)+","+(height + 0.75*margin.bottom)+")")
   .attr("dy","-0.3em")
   .style("text-anchor","middle")
   		.attr("fill", "white")
   .text("Time Step")

// create y-axis label
svgr.append("text")
   .attr("transform","rotate(-90)")
   .attr("y", 0 - margin.left)
   .attr("x", 0 - (height/2))
   .attr("dy", "1em")
   .style("text-anchor","middle")
   		.attr("fill", "white")
   .text("Data Rate (bits/second)")

// 9. Append the path, bind the data, and call the line generator
var pathr = svgr.append("path")
    .attr("clip-path","url(#clipr)")
    .datum(datar)
    .attr("class", "stroke-med no-fill stroke-orange")
    .attr("d", liner);

//
// capacity plot
//

// channel capacity (b/s/Hz) given SNR in dB
function efficiency(SNRdB) { return Math.log2(1.0 + Math.pow(10,SNRdB/10)); }

// capacity curve
// (-10, 4 Mb/s, 0.1375 b/s/Hz), (40 dB, 382 Mb/s, 13.288 b/s/Hz)
var datac = d3.range(-10,40+0.01).map(function(d,i) { return {"x":d, "y":efficiency(d)} })

var svgc = d3.select("body").append("svg")
    .attr("width",  width  + margin.left + margin.right)
    .attr("height", height + margin.top +  margin.bottom)
    .attr("id", "svg-capacity")
  .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// create scale
var sscale = d3.scaleLinear().domain([-10,40]).range([0, width]); // snr (Eb/N0?)
var cscale = d3.scaleLog   ().domain([0.5, 8]).range([height, 0]); // capacity (b/s/Hz)
//.domain([schemes[0].rate, schemes[schemes.length-1].rate])

svgc.append("defs").append("clipPath")
    .attr("id", "clip")
  .append("rect")
    .attr("width", width)
    .attr("height", height);
	
		svgc.append("rect")
		.attr("width", "86.2%")
		.attr("height", "81%")
		.attr("fill", "black");
		

svgc.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(sscale));

//var yTickValues = [0.1,0.2,0.5,1,2,5,10,20]
var yTickValues = [];
schemes.forEach(function(d,i) { yTickValues.push(d.rate); });

svgc.append("g")
    .attr("class", "y axis")
    .call(d3.axisLeft(cscale)
      .tickValues(yTickValues)
        .tickFormat(function(d) { return d3.format(".2f")(d); } ))

// grid lines
svgc.append("g").attr("class","grid").call(d3.axisBottom(sscale).tickFormat("").tickSize(height));
svgc.append("g").attr("class","grid").call(d3.axisLeft  (cscale).tickFormat("").tickSize(-width).tickValues(yTickValues));

// create x-axis axis label
svgc.append("text")
   .attr("transform","translate("+(width/2)+","+(height + 0.75*margin.bottom)+")")
   .attr("dy","-0.3em")
   .style("text-anchor","middle")
   		.attr("fill", "white")
   .text("SNR (dB)")

// create y-axis label
svgc.append("text")
   .attr("transform","rotate(-90)")
   .attr("y", 0 - margin.left)
   .attr("x", 0 - (height/2))
   .attr("dy", "1em")
   .style("text-anchor","middle")
   		.attr("fill", "white")
   .text("Spectral Efficiency (bits/second/Hz)")

// clip paths
svgc.append("clipPath").attr("id","clipf").append("rect").attr("width",width).attr("height",height);

// line generator for capacity, mod/cod curves
var linec = d3.line()
    .x(function(d) { return sscale(d.x); })  // map SNR
    .y(function(d) { return cscale(d.y); }); // map capacity

// 9. Append the path, bind the data, and call the line generator
var pathc = svgc.append("path")
    .attr("clip-path","url(#clipf)")
    .datum(datac)
    .attr("class", "stroke-light no-fill stroke-green-o")
    .attr("d", linec);

// 9. Append the path, bind the data, and call the line generator
var datam = d3.range(schemes.length)
              .map(function(d,i) { return {"x":schemes[i].SNR, "y":schemes[i].rate} });
var pathc = svgc.append("path")
    .attr("clip-path","url(#clipf)")
    .datum(datam)
    .attr("class", "stroke-light no-fill stroke-green-o dashed")
    .attr("d", linec);

// add operating ponit
svgc.append('g')
    .selectAll("dot")
    .data( [{"x":0, "y":efficiency(0)}] )
    .enter()
    .append("circle")
      .attr("cx", function (d) { return sscale(d.x); } )
      .attr("cy", function (d) { return cscale(d.y); } )
      .attr("r", 5)
      .attr("class", "stroke-light stroke-green-o")
      .style("fill", "#66ff00");
	  

function update_plot(band,gain,modcod) {
    if (band !=null) { bw = band;  }
    if (gain !=null) { gn = gain;  }
    if (modcod!=null){ mc = modcod;}

    // compute and display SNR
    snr = gn - n0 - 10*Math.log10(bw);
    document.querySelector('#snr').value = d3.format(".2f")(snr) + " dB";

    // compute and display spectral efficiency, capacity
    let R = efficiency(snr);    // spectral efficiency (b/s/Hz)
    let C = fs * bw * R;        // capacity (b/s)
    var [scale_cap,units_cap] = scale_units(C,0.1);
    document.querySelector('#cap').value = d3.format(".1f")(C*scale_cap) + " " + units_cap + "b/s";
    document.querySelector('#eta').value = d3.format(".3f")(R) + " " + "b/s/Hz";

    // compute and display link margin
    lmargin = snr - schemes[mc].SNR;
    document.querySelector('#margin').value = d3.format(".2f")(lmargin) + " dB";
    document.querySelector('#margin').style.color = lmargin < 0 ? "red" : "white";

    // compute and display actual data rate
    valid = lmargin >= 0;
    if (valid) {
        rate = schemes[mc].rate * bw * fs;
        var [scale_rate,units_rate] = scale_units(rate,0.1);
        let percent_capacity = 100 * rate / C;
        document.querySelector('#rate').value = d3.format(".1f")(rate*scale_rate) + " " + units_rate + "bps (" +
                                                d3.format(".1f")(percent_capacity) + "% capacity)";
        document.querySelector('#rate').style.color = "white";
    } else {
        rate = 0;
        document.querySelector('#rate').value = "0 bps";
        document.querySelector('#rate').style.color = "red";
    }

    // generate power spectral density, compensating for bandwidth
    dataf = generate_psd(fc,bw,gn,n0);
    pathf.datum(dataf).attr("d", linef);

    // update capacity value
    d3.selectAll("#svg-capacity circle")
      .data( [{"x":snr, "y":R}] )
      .attr("cx", function(d) { return sscale(d.x); })
      .attr("cy", function(d) { return cscale(schemes[mc].rate); })
      .attr("class", valid ? "stroke-med stroke-green" : "stroke-med stroke-red")
      .style("fill", (rate > 0.0) ? "#00FF00": "#FF0000");

}

function toggle() {
    if (running) { stop()    }
    else         { restart() }
}

function populateCallback() {
    let selection = document.getElementById("strategy").value;
    let u = 'return 0;'
    switch (selection) {
    case 'a0': u = 'return 4;'; break;
    case 'a1': u = 'return 11*Math.random();'; break;
    case 'a2': u = 'return closed ? current+1 : current-1;'; break;
    case 'a3':
        u  = '// check current link margin and adjust scheme appropriately\n';
        u += 'if      (lmargin > 4) { return current+1; }\n';
        u += 'else if (lmargin > 1) { return current;   }\n';
        u += 'else                  { return current-1; }\n';
        break;
    case 'a4':
        u  = '// find highest scheme that will close for given SNR\n';
        u += 'for (let i=modcod.length-1; i>=0; i--) {\n';
        u += '  if (modcod[i].SNR <= SNR) { return i; }\n';
        u += '}\n';
        u += 'return 0;';
        break;
    default:
        return;
    }
    document.querySelector('#userfunction').value = u;
}

function restart() {
    console.log("go!");
    // pull user callback value and disable editing of text area
    document.querySelector('#toggle').value = 'Stop';
    document.querySelector('#userfunction').disabled = true;
    callback = new Function("timer","modcod","current","SNR","margin","closed",
                            document.querySelector('#userfunction').value);
    running = true;
    reset();
    step_interval();
}

function stop() {
    console.log("stop!");
    running = false;
    document.querySelector('#toggle').value = 'Go!';
    document.querySelector('#userfunction').disabled = false;
}

function reset() {
    datar = d3.range(0,num_steps-1).map(function(f) { return {"y":1} });
    mc = 0;
    [gn,bw] = gn_bw_profile(0);
    counter = num_steps;
    bits  = 0;
    outages = 0;
    // clear display
    document.querySelector('#timer').value   = d3.format(",")(counter);
    document.querySelector('#outages').value = d3.format(",")(outages);
    document.querySelector('#bits').value    = d3.format(",")(bits);
    // set colors to black
    document.querySelector('#timer').style.color   = "white";
    document.querySelector('#outages').style.color = "white";
    document.querySelector('#bits').style.color    = "white";
}

async function step_interval() {
    await new Promise((res, req) => { setTimeout(res, step_dwell_time) });
    step();
    if (running) {
        let user_modcod = callback(counter,schemes,mc,snr,margin,valid);
        mc = Math.max(0, Math.min(schemes.length-1, Math.round(user_modcod)));
        if (typeof mc != "number" || isNaN(mc)) { mc = 0; }
        console.log("user value: ", user_modcod, ", interpreting as: ", mc);
        step_interval();
    } else {
        finished();
    }
}

const gn_min = -35; // dB
const gn_max = 0; // dB

//time, gain, and bandwidth profiles
function gn_bw_profile(i) {
    let t = i * step_dwell_time * 1e-3;
    // let gain = -5 + 10*Math.log10(0.001 + (0.5 + 0.5*Math.cos(2*Math.PI*0.04*t + 0.7))) *
    //        Math.exp(-0.05*t);

    // let gain = -5 + 100*Math.log10(0.001 + (0.5 + 0.5*Math.pow(Math.cos(2*Math.PI*0.04*t + 0.7), 4)))*Math.exp(-0.05*t);
    let gain = -1 + 100*Math.log10(0.001 + (0.5 + 0.5*Math.pow(Math.cos(2*Math.PI*0.04*t + 0.7), 4)));
    // let bandwidth = (0.1 + 0.8*(0.5 + 0.5*Math.cos(2*Math.PI*0.07*t + 1.5))) *
    //         Math.exp(-0.015*t);
    // console.log(bandwidth);
    let bandwidth = 0.5282948806670812;
    return [gain,bandwidth];
}

function step() {
    // gain and bandwidth profiles
    [gn,bw] = gn_bw_profile(num_steps - counter);
    counter -= 1;

    update_plot();

    // update historical plot
    datar.push({"y":Math.max(rate,1)});
    datar.shift();
    pathr.datum(datar).attr("d", liner);

    // update counters
    bits += Math.round(rate * step_dwell_time * 1e-3);
    outages += valid ? 0 : 1;
    document.querySelector('#bits').value    = d3.format(",")(bits);
    document.querySelector('#outages').value = d3.format(",")(outages);
    document.querySelector('#timer').value   = d3.format(",")(counter);
    if (counter <= 0) { stop(); }
}

function finished() {
    document.querySelector('#bits').style.color = "#008040";
    document.querySelector('#outages').style.color = outages > 0 ? "#800000" : "#008040";
}

// set initial values and replot
reset();
update_plot();

</script>
</html>

