<!DOCTYPE html>

<html lang="en-US" style="display: flex;">

<head>
  <title>HLSI Ex 27</title>
  <meta charset="UTF-8" />
  <link rel="stylesheet" type="text/css" media="all" href="hlsi.css">
  <link rel=stylesheet type=text/css href=sidebar.css />
  <link rel=stylesheet type=text/css href=codemirror.min.css />
  <link rel=stylesheet type=text/css href=blackboard.min.css />
  <link rel='stylesheet' type='text/css' href='./x3dom/x3dom.css'>
  </link>
  <link href='https://css.gg/minimize-alt.css' rel='stylesheet'>
  <style>
    output {
      font-weight: bold;
    }

    .modes {
      display: flex;
      flex-direction: row;
    }
  </style>
  <script src=d3.v5.min.js></script>
  <script src=fft.js></script>
  <script src=common.js></script>
  <script src=signal.js></script>
  <!-- <script src=sliders.js></script> -->
  <script src=slidersMultiSignals.js></script>
  <!-- <script src=powerSpectrumPlot.js></script> -->
  <script type='text/javascript' src='./x3dom/x3dom.js'></script>
  <script src=powerSpectrumPlot_2D.js></script>
  <script src=powerSpectrumPlot_3D.js></script>
  <script src=powerSpectrumPlot_2D_MultiSignals.js></script>
  <script src=powerSpectrumPlot_3D_MultiSignals.js></script>
  <script src=spectralEfficiencyPlot_BarChart.js></script>
  <script src=sinrPlot_BarChart.js></script>
  <script src="averageThroughputPlot_BarChart.js"></script>
  <script src="modeController.js"></script>
  <script src="patterns_matlab.js"></script>
  <script src=label.js></script>
  <script src=timer.js></script>
  <script src=capacityBanner.js></script>
  <script src=capacityRunner_multisignal.js></script>
  <script src=scriptController.js></script>
  <script src=codemirror.min.js></script>
  <script src=codeMirror_javascript.js></script>
  <script src=throughputPlotMultiSignals.js></script>
  <script src=spatialMobility.js></script>
  <script src=hoppingInterferer.js></script>
  <script src="https://unpkg.com/d3-simple-slider"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>

  <style>
    .grid-container-main {
      display: flex;
      flex-direction: column;
    }

    .grid-item {
      padding: 2px;
      font-size: 30px;
    }

    .grid-container-item {
      display: flex;
      flex-direction: row;
    }

    .grid-item {
      display: flex;
      flex-direction: row;
    }

    .grid-container {
      display: flex;
      flex-direction: row;
    }

    .throughput-heading {
      font-size: 1rem;
    }

    .linkinputs {
      width: 100%;
      margin-top: -1.5%;
      display: flex;
      flex-direction: row;
    }

    input.slider_bw {
      width: auto;
    }

    .PU_controls {
      display: flex;
      flex-direction: row;
      height: 2rem;
    }

    #tx_pattern_options {
      display: none;
      margin-left: 2em;
      margin-bottom: -2em;
      font-size: large;
    }


    .tx-axes {
      display: none;
    }

    #tx_red_cyl {
      display: none;
    }

    #manual-angle-options-tx {
      display: none;
    }

    #manual-angle-options-rx {
      display: none;
    }


    @media screen and (max-width: 1500px) {
      .grid-container {
        display: flex;
        flex-direction: column;
        padding: 2px;
      }

      .grid-container-item {
        display: flex;
        flex-direction: column;
      }

      .grid-item {
        display: flex;
        flex-direction: column;
      }

      .grid-container {
        display: flex;
        flex-direction: column;
      }

    }

    .table {
      width: 100%;
    }

    td,
    th {
      border: 1px solid white;
      text-align: center;
      padding: 8px;
    }
  </style>
</head>


<body style="margin:0;">
  <section class="banner" style="position: fixed; z-index: 11; background: rgba(0,0,0,0.85)">
    <div
      style="margin-left: 6%; font-size: 1.3rem; margin-top: 0.3%; font-family: sans-serif; order: 1; width: inherit;">
      <span style="color: #ddd;">Exercise 27</span> In Progress - RFFE Spectrum Sharing -- Position, Path Loss, and
      Mobility -- Basic
      Controls
    </div>
    <div style="order: 2; margin-left: auto; margin-right: 2%; display: flex;">
      <span
        style="font-size: 250%; font-family: monospace; letter-spacing: 2px; margin-left: auto; margin-right: 5px; color: #e6d9ba;"></span>
      <div style="width: 20%;">
        <img style="width: 100%;" src="images/wireless-logo.png">
      </div>
    </div>
  </section>

  <div class="content-section" style="margin: 0% 2%; margin-top: 5%;">

    <p id=capacityBanner style="display: none;">
    </p>

    <div class="modes">
      <div>
        <p><label for="mode">Select mode:</label> &nbsp;
          <select id="mode" onchange="onModeChange()">
            <option id="beginner" value="beginner">Beginner</option>
            <option id="advanced" value="advanced">Advanced</option>
          </select>
        </p>
      </div>

      <div class="modes" style="margin-left: 2rem;">
        <p>
          <label for="strategy">Select SINR calculation option:</label> &nbsp;
          <select id="strategy" onchange="onCategoryChange()">
            <option id="default" value="" selected disabled hidden>Select SINR calculation option...</option>
            <option value="a0">Ideal filter with bandwidth equal to signal bandwidth</option>
            <option id="ideal1" value="a1" disabled>Ideal filter - equal excess bandwidth</option>
            <option id="ideal2" value="a2" disabled>Ideal filter - unequal excess bandwidth</option>
            <option id="nonlinear" value="a4" disabled>Nonlinear front end</option>
            <option id="ideal3" value="a5" disabled>Nonlinear front end - preselector bandwidth over entire frequency
              range</option>
          </select>


        <div id="multiplierDiv" style="display: none;">
          <p>
            <label style="margin-left: 2rem;" for="strategy">BW mult.:</label> &nbsp;
            <input style="width: 5rem;" id="multiplier" type="text" value="1" oninput="this.value = this.value
              .replace(/[^0-9.]/g, '').replace(/(\..*?)\..*/g, '$1').replace(/^0[^.]/, '0').replace(/^[0.].*/, '');" />
          </p>
        </div>

        <div style="margin-left: 2rem;">
          <p>
            <input id="apply" type="button" value="Apply Selection" onclick="calculateSINR()">
          </p>
        </div>
        </p>
      </div>
    </div>


  </div>

  <div style="width: 30%; display:inline-flex; margin-left:1%; margin-top: 1%;">
    <div style="display: inline-flex;">
      <div style="width: 28px; height: 15px; background:rgba(163,36,36,255)"></div>
      <div style="margin-left: 5px; overflow: hidden; white-space: nowrap;">Transmitter</div>
    </div>

    <div style="display: inline-flex; margin-left: 10px;">
      <div style="width: 28px; height: 15px; background:rgba(0,176,240,255);"></div>
      <div style="margin-left: 5px; overflow: hidden; white-space: nowrap;">Receiver</div>
    </div>
  </div>
  </div>

  <div>
    <div id="tx_pattern_options">
      <div style="width: 28px; height: 15px; background:rgba(163,36,36,255); margin:auto"></div>
      <p><label for="tx_pattern">&nbsp;&nbsp;Type of Transmitter Pattern:</label> &nbsp;
        <select id="tx_pattern">
          <option id="vertical_isotropic" value="vertical_isotropic">Vertical Isotropic</option>
          <option id="horizontal_isotropic" value="horizontal_isotropic">Horizontal Isotropic</option>
          <option id="halfwave" value="halfwave">Half-wave dipole</option>
          <option id="sdipole" value="sdipole">Small dipole</option>
          <option id="dirAnt_sideLobe" value="dirAnt_sideLobe">Directional antenna with Flat beam and Side Lobe</option>
        </select>
      </p> &nbsp; &nbsp; &nbsp;
      <p>
        <label for="polarization">
          <input type="checkbox" id="vertical_tx" value="vertical">
          Vertical
          <input type="checkbox" id="horizontal_tx" value="horizontal">
          Horizontal
        </label><br>
      </p>&nbsp; &nbsp;
      <p id="manual-angle-options-tx">
        <label for="theta_rx_manual">Theta (0-180)</label> &nbsp; &nbsp;
        <input style="width: 3.5rem; height: 1.2rem;" id="theta_tx_manual" type="text" value="20"
          oninput="this.value = this.value
        .replace(/[^0-9.-]/g, '').replace(/(\..*?)\..*/g, '$1').replace(/^0[^.]/, '0').replace(/^[-]*[0-9]+[.]*[0-9]*[-]/, '0');" /> &nbsp; &nbsp;
        <label for="phi_rx_manual">Phi (0-360)</label> &nbsp; &nbsp;
        <input style="width: 3.5rem; height: 1.2rem;" id="phi_tx_manual" type="text" value="20"
          oninput="this.value = this.value
        .replace(/[^0-9.-]/g, '').replace(/(\..*?)\..*/g, '$1').replace(/^0[^.]/, '0').replace(/^[-]*[0-9]+[.]*[0-9]*[-]/, '0');" /> &nbsp; &nbsp;

        <input id="apply" type="button" value="Apply" onclick="manualInput()"> &nbsp; &nbsp;
      </p>
    </div>
    <div style="display: inline-flex; margin-left: 2em; font-size: large;">
      <div style="width: 28px; height: 15px; background:rgba(0,176,240,255); margin:auto"></div>
      <p><label for="antenna_pattern">&nbsp;&nbsp;Type of Receiver Pattern:</label> &nbsp&nbsp&nbsp&nbsp&nbsp;
        <select id="antenna_pattern">
          <option id="vertical_isotropic" value="vertical_isotropic">Vertical Isotropic</option>
          <option id="horizontal_isotropic" value="horizontal_isotropic">Horizontal Isotropic</option>
          <option id="halfwave" value="halfwave">Half-wave dipole</option>
          <option id="sdipole" value="sdipole">Small dipole</option>
          <option id="dirAnt_sideLobe" value="dirAnt_sideLobe">Directional antenna with Flat beam and Side Lobe</option>
        </select>
      </p> &nbsp; &nbsp; &nbsp;
      <p>
        <label for="polarization">
          <input type="checkbox" id="vertical_rx" value="vertical">
          Vertical
          <input type="checkbox" id="horizontal_rx" value="horizontal">
          Horizontal
        </label><br>
      </p>&nbsp; &nbsp;
      <p id="manual-angle-options-rx">
        <label for="theta_rx_manual">Theta (0-180)</label> &nbsp; &nbsp;
        <input style="width: 3.5rem; height: 1.2rem;" id="theta_rx_manual" type="text" value="20"
          oninput="this.value = this.value
        .replace(/[^0-9.-]/g, '').replace(/(\..*?)\..*/g, '$1').replace(/^0[^.]/, '0').replace(/^[-]*[0-9]+[.]*[0-9]*[-]/, '0');" /> &nbsp; &nbsp;
        <label for="phi_rx_manual">Phi (0-360)</label> &nbsp; &nbsp;
        <input style="width: 3.5rem; height: 1.2rem;" id="phi_rx_manual" type="text" value="20"
          oninput="this.value = this.value
        .replace(/[^0-9.-]/g, '').replace(/(\..*?)\..*/g, '$1').replace(/^0[^.]/, '0').replace(/^[-]*[0-9]+[.]*[0-9]*[-]/, '0');" /> &nbsp; &nbsp;

        <input id="apply" type="button" value="Apply" onclick="manualInput()"> &nbsp; &nbsp;
      </p>
    </div>
    <div>
      <div style="display: inline-flex; margin-left: 2em; font-size: large; margin-top: -1.5%;">
        <label for="path_loss">Path Loss (dB) : </label> &nbsp;
        <label id="path_loss" for="path_loss"></label>
        &nbsp; &nbsp; &nbsp;
        <label for="power_rx_db">Power at Receiver (dB) : </label> &nbsp;
        <label id="power_rx_db" for="power_rx_db"></label>
        &nbsp; &nbsp; &nbsp;
        <label for="rec_trans_dist_label">Receiver - Transmitter Distance : </label> &nbsp;
        <label id="rec_trans_dist" for="rec_trans_dist"></label>
        &nbsp; &nbsp; &nbsp;
      </div>
      <!-- <button class="toggle-button" onclick="toggleSliders()">
        Toggle Sliders
      </button> -->
    </div>
  </div>

  <div id="togglebutton" style="padding-top: 3%;">
    <div id="toggleValueDisplay" style="padding-left: 30%;">You are Controlling: RX "Press to toggle"</div>
    <div style="padding-left: 35%;">
    <button class="toggle-button" id="toggle-button" onclick="toggleSliders()">
      Toggle RX/TX
    </button>
  </div>
  </div>


  <div style="display: flex;">
    <div id="x3dModelWindow" style="display: flex;flex-direction: column;">
      <div id="x3dMain" style="display: flex;">
        <div id="sliderLeft" style="display: flex;flex-direction: row;">
          <label for="sliderForVertical" style="writing-mode: tb-rl;transform: rotate(-180deg);">Move
            North-South</label>
          <input type="range" id="sliderForVertical" min="-12" max="12" step="any" value="0" class="vertical-slider" style="transform: rotate(180deg);">
        </div>

        <x3d id='x3dElement' showStat='false' showLog='false' width='1020px' height='500px'>
          <scene DEF='scene'>
              <physicalenvironmentlight diffuse="simpleDiffuse.dds" specular="simpleSpecular.dds"></physicalenvironmentlight>
              <Background backUrl='nz.png' bottomUrl='ny.png' frontUrl='pz.png' leftUrl='nx.png' rightUrl='px.png' topUrl='py.png'></Background>
              <!-- Adjusted Viewpoint with modified position and orientation -->
              <Viewpoint DEF="OverheadView" position="0 100 0" orientation="1 0 0 -1.57"
                         zNear="0.1" zFar="1000" centerOfRotation="0 0 0" fieldOfView="0.78540"
                         description="Overhead View"></Viewpoint>
              <!-- <NavigationInfo type='turntable' typeParams='0.0 0.0 0.1 1.5'></NavigationInfo> -->

            <!-- Transmitter and Antenna -->
            <transform id="transmitterTranslation" translation="0 0 0">

              <transform DEF='ant_1' translation='0 -2.5 0'>
                <shape>
                  <Appearance>
                    <Material diffuseColor="0 0.6902 0.9412" />
                  </Appearance>
                  <cylinder radius='0.25' height='5'></cylinder>
                </shape>
                <!-- <viewpoint></viewpoint> -->
              </transform>

              <matrixTransform id="rxRotation">

                <transform rotation="1 0 0 3.1415">

                  <switch id="receiver-geometry" whichchoice="0">

                    <transform class="pattern-models" rotation="0 0 1 1.5707">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0.6902 0.9412" />
                        </Appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                    </transform>

                    <transform class="pattern-models" rotation="0 0 1 1.5707">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0.6902 0.9412" />
                        </Appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                    </transform>

                    <transform class="pattern-models" rotation="0 0 1 1.5707">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0.6902 0.9412" />
                        </Appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                      <inline id="inline-model" url='vert_iso_pat.x3d' />
                    </transform>

                    <transform class="pattern-models" rotation="0 0 1 1.5707">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0.6902 0.9412" />
                        </Appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                      <inline id="inline-model" url='vert_iso_pat.x3d' />
                    </transform>

                    <transform class="pattern-models">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0.6902 0.9412" />
                        </Appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                    </transform>

                    <transform class="pattern-models">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0.6902 0.9412" />
                        </Appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                      <inline id="inline-model" url='horiz_iso_pat.x3d' />
                    </transform>

                    <transform class="pattern-models">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0.6902 0.9412" />
                        </Appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                    </transform>

                    <transform class="pattern-models">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0.6902 0.9412" />
                        </Appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                      <inline id="inline-model" url='horiz_iso_pat.x3d' />
                    </transform>

                    <transform class="pattern-models">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0 1" />
                        </Appearance>
                        <cylinder radius='0.25' height='5'></cylinder>
                      </shape>
                    </transform>

                    <transform class="pattern-models">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0 1" />
                        </Appearance>
                        <cylinder radius='0.25' height='5'></cylinder>
                      </shape>
                    </transform>

                    <transform class="pattern-models">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0 1" />
                        </Appearance>
                        <cylinder radius='0.25' height='5'></cylinder>
                      </shape>
                      <inline id="inline-model" url='halfwave_pat.x3d' />
                    </transform>

                    <transform class="pattern-models">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0 1" />
                        </Appearance>
                        <cylinder radius='0.25' height='5'></cylinder>
                      </shape>
                      <inline id="inline-model" url='halfwave_pat.x3d' />
                    </transform>

                    <transform class="pattern-models">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0 1" />
                        </Appearance>
                        <cylinder radius='0.25' height='1'></cylinder>
                      </shape>
                    </transform>

                    <transform class="pattern-models">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0 1" />
                        </Appearance>
                        <cylinder radius='0.25' height='1'></cylinder>
                      </shape>
                    </transform>

                    <transform class="pattern-models">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0 1" />
                        </Appearance>
                        <cylinder radius='0.25' height='1'></cylinder>
                      </shape>
                      <inline id="inline-model" url='small_dip_pat.x3d' />
                    </transform>

                    <transform class="pattern-models">
                      <shape>
                        <Appearance>
                          <Material diffuseColor="0 0 1" />
                        </Appearance>
                        <cylinder radius='0.25' height='1'></cylinder>
                      </shape>
                      <inline id="inline-model" url='small_dip_pat.x3d' />
                    </transform>


                    <transform class="pattern-models">
                      <Transform rotation="0 0 1 1.5707">
                        <shape>
                          <Appearance>
                            <Material diffuseColor="0 0 1" />
                          </Appearance>
                          <Cone bottomradius='1.5' height='3' />
                        </shape>
                      </Transform>
                    </transform>

                    <transform class="pattern-models">
                      <Transform rotation="0 0 1 1.5707">
                        <shape>
                          <Appearance>
                            <Material diffuseColor="0 0 1" />
                          </Appearance>
                          <Cone bottomradius='1.5' height='3' />
                        </shape>
                      </Transform>
                    </transform>

                    <transform class="pattern-models">
                      <Transform rotation="0 0 1 1.5707">
                        <shape>
                          <Appearance>
                            <Material diffuseColor="0 0 1" />
                          </Appearance>
                          <Cone bottomradius='1.5' height='3' />
                      </Transform>
                      </shape>
                      <inline id="inline-model" url='directional_pat.x3d' />
                    </transform>

                    <transform class="pattern-models">
                      <Transform rotation="0 0 1 1.5707">
                        <shape>
                          <Appearance>
                            <Material diffuseColor="0 0 1" />
                          </Appearance>
                          <Cone bottomradius='1.5' height='3' />
                        </shape>
                      </Transform>
                      <inline id="inline-model" url='directional_pat.x3d' />
                    </transform>


                  </switch>

                  <shape DEF='point'>
                    <appearance>
                      <material diffuseColor='1 0 0'></material>
                      <lineProperties applied='TRUE' linewidthScaleFactor='0.01'></lineProperties>
                    </appearance>
                    <cylinder height='50' radius='0.1'></cylinder>
                  </shape>





                </transform>
              </matrixTransform>
            </transform>

            <!-- GROUND PLANE, FOR BETTER ORIENTATION -->
            <transform translation='0 -5.5 0' rotation='1 0 0 -1.57'>
              <shape>
                <appearance>
                  <Material ambientIntensity='0.25' diffuseColor='0.510609 0.17264 0.059872' shininess='0.933333' specularColor='0.533333 0.533333 0.533333'/>
                </appearance>
                <box solid='true' size='60 60 2'></box>
              </shape>
            </transform>
            <!--26 16 2-->


            <!--This is the transmitter, not the receiver-->
            <!-- <transform translation='0 0 -12'> -->
            <transform id="receiver" translation='0 0 -12'>
              <transform translation='0 -2.5 0'>
                <shape>
                  <appearance>
                    <material diffuseColor='0.71 0.396 0.114'></material>
                  </appearance>
                  <cylinder radius='0.25' height='5'></cylinder>
                </shape>
              </transform>

              <matrixTransform id="txRotation">
                <transform id="receiver-temp" rotation="1 0 0 3.1415">
                  <switch id="tx-geometry" whichchoice="1">
                    <transform rotation="0 0 1 1.5707">
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                    </transform>

                    <transform rotation="0 0 1 1.5707">
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                    </transform>

                    <transform rotation="0 0 1 1.5707">
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                      <inline id="inline-model" url='vert_iso_pat.x3d' />
                    </transform>

                    <transform rotation="0 0 1 1.5707">
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                      <inline id="inline-model" url='vert_iso_pat.x3d' />
                    </transform>

                    <transform>
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                    </transform>

                    <transform>
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                      <inline id="inline-model" url='horiz_iso_pat.x3d' />
                    </transform>

                    <transform>
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                    </transform>

                    <transform>
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <Cylinder radius='0.8' height='0.05' />
                      </shape>
                      <inline id="inline-model" url='horiz_iso_pat.x3d' />
                    </transform>

                    <transform>
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <cylinder radius='0.25' height='5'></cylinder>
                      </shape>
                    </transform>

                    <transform>
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <cylinder radius='0.25' height='5'></cylinder>
                      </shape>
                    </transform>

                    <transform>
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <cylinder radius='0.25' height='5'></cylinder>
                      </shape>
                      <inline id="inline-model" url='halfwave_pat.x3d' />
                    </transform>

                    <transform>
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <cylinder radius='0.25' height='5'></cylinder>
                      </shape>
                      <inline id="inline-model" url='halfwave_pat.x3d' />
                    </transform>

                    <transform>
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <cylinder radius='0.25' height='1'></cylinder>
                      </shape>
                    </transform>

                    <transform>
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <cylinder radius='0.25' height='1'></cylinder>
                      </shape>
                    </transform>

                    <transform>
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <cylinder radius='0.25' height='1'></cylinder>
                      </shape>
                      <inline id="inline-model" url='small_dip_pat.x3d' />
                    </transform>

                    <transform>
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <cylinder radius='0.25' height='1'></cylinder>
                      </shape>
                      <inline id="inline-model" url='small_dip_pat.x3d' />
                    </transform>

                    <transform rotation="0 0 1 1.5707">
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <Cone bottomradius='1.5' height='3' />
                      </shape>
                    </transform>

                    <transform rotation="0 0 1 1.5707">
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <Cone bottomradius='1.5' height='3' />
                      </shape>
                    </transform>

                    <transform rotation="0 0 1 1.5707">
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <Cone bottomradius='1.5' height='3' />
                      </shape>
                      <transform rotation="0 0 1 -1.5707">
                        <inline id="inline-model" url='directional_pat.x3d' />
                      </transform>
                    </transform>

                    <transform rotation="0 0 1 -1.5707">
                      <shape>
                        <appearance>
                          <material diffuseColor='1 0 0'></material>
                        </appearance>
                        <Cone bottomradius='1.5' height='3' />
                      </shape>
                      <transform rotation="0 0 1 1.5707">
                        <inline id="inline-model" url='directional_pat.x3d' />
                      </transform>
                    </transform>
                  </switch>
                </transform>
              </matrixTransform>
            </transform>
            <!-- TRANSLATION GIZMO (CONTAINING PLANE SENSOR AND SENSOR GEOMETRY) -->
            <group>
              <planeSensor id="transmitterPlane" autoOffset='true' axisRotation='1 0 0 -1.57' minPosition='-12 0'
                maxPosition='12 0' onoutputchange='processTranslationGizmoEvent(event)'>
              </planeSensor>
            </group>
            <Switch whichChoice="0" id="rotation_gizmo">
              <transform id='RotationHandleTransform2'>
              </transform>
            </Switch>
          </scene>
        </x3d>

        <div id="sliderRight" style="display: flex; flex-direction: row;">

          <input type="range" id="sliderForRotateX" min="0" max="360" step="any" value="0" class="vertical-slider">
          <label for="sliderForRotateX" style="writing-mode: tb-rl;transform: rotate(-180deg);">Point Antenna Up-Down
            (Elevation)
          </label>
        </div>
        <div id="sliderRight2" style="display: none;">
          <label for="sliderForRotateY" style="writing-mode: tb-rl;transform: rotate(-180deg);">Point Receiver Up-Down
            (Elevation)
          </label>
          <input type="range" id="slider2ForRotateX" min="0" max="360" step="any" value="0" class="vertical-slider"
            style="accent-color: red">

        </div>
      </div>
      <div id="sliderBottom">
        <div id="sliderBottomLeft" style="
      display: flex;
      flex-direction: column;
  ">
          <input type="range" id="sliderForHorizontal" min="-10" max="10" step="any" value="0">
          <label for="sliderForHorizontal">Move East-West
          </label>
        </div>
        <div id="sliderBottomRight" style="
      display: flex;
      flex-direction: column;
  ">
          <input type="range" id="sliderForRotateY" min="0" max="360" step="any" value="0" style="transform: rotate(180deg);">
          <label for="sliderForRotateY">Point Antenna Left-Right (Azimuth)
          </label>
        </div>
      </div>

      <!-- Group 2 of Sliders (Initially hidden) -->
      <div id="sliderGroup2" style="display: none;">

        <div id="sliderBottom2">
          <div id="sliderBottomRight2">
            <input type="range" id="slider2ForRotateY" min="0" max="360" step="any" value="0" style="accent-color: red;transform: rotate(180deg);">
            <label for="sliderForRotateY">Point Antenna Left-Right (Azimuth)
            </label>
          </div>
        </div>
      </div>

      <div style="display: flex; flex-direction: row;">
        <table id="angles-table-rx" width="100px" style="margin: 20px;">
          <caption>RX-Details</caption>
          <tr>
            <th>Angle</th>
            <th>Value</th>
          </tr>
          <tr>
            <td>X<sub>absolute</sub></td>
            <td id="angle-x-table-rx">0</td>
          </tr>
          <tr>
            <td>Y<sub>absolute</sub></td>
            <td id="angle-y-table-rx">0</td>
          </tr>
          <tr>
            <td>Z<sub>absolute</sub></td>
            <td id="angle-z-table-rx">0</td>
          </tr>
          <tr>
            <td>&theta;<sub>absolute</sub></td>
            <td id="angle-theta-table-rx">0</td>
          </tr>
          <tr>
            <td>&Phi;<sub>absolute</sub></td>
            <td id="angle-phi-table-rx">0</td>
          </tr>
          <tr>
            <td>&theta;<sub>rx-tx</sub></td>
            <td id="angle-theta-table-rx-rel">90</td>
          </tr>
          <tr>
            <td>&Phi;<sub>rx-tx</sub></td>
            <td id="angle-phi-table-rx-rel">90</td>
          </tr>
        </table>

        <table id="angles-table-tx" width="100px" style="margin: 20px;">
          <caption>TX-Details</caption>
          <tr>
            <th>Angle</th>
            <th>Value</th>
          </tr>
          <tr>
            <td>X<sub>absolute</sub></td>
            <td id="angle-x-table-tx">0</td>
          </tr>
          <tr>
            <td>Y<sub>absolute</sub></td>
            <td id="angle-y-table-tx">0</td>
          </tr>
          <tr>
            <td>Z<sub>absolute</sub></td>
            <td id="angle-z-table-tx">0</td>
          </tr>
          <tr>
            <td>&theta;<sub>absolute</sub></td>
            <td id="angle-theta-table-tx">0</td>
          </tr>
          <tr>
            <td>&Phi;<sub>absolute</sub></td>
            <td id="angle-phi-table-tx">0</td>
          </tr>
          <tr>
            <td>&theta;<sub>tx-rx</sub></td>
            <td id="angle-theta-table-tx-rel">90</td>
          </tr>
          <tr>
            <td>&Phi;<sub>tx-rx</sub></td>
            <td id="angle-phi-table-tx-rel">90</td>
          </tr>
        </table>

      </div>
    </div>

    <div class="grid-container-main">
      <div class="grid-container-item">


        <div class="grid-item">
          <div class="grid-container">
            <div class="grid-item" id="sinr_parent" style="width: 360px; height: 320px;">
              <canvas id="sinr-bar-chart" style="width: 100%; height: 100%;"></canvas>
            </div>
          </div>
        </div>
      </div>
      <div class="grid-container-item">
        <div class="grid-item">
          <div class="grid-item" id="sinr_parent" style="width: 360px; height: 320px;">
            <canvas id="spectral-efficiency-bar-chart" style="width: 100%; height: 100%;"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>

  <nav id="buttons-nav">
    <button id="btnThroughput" onclick="toggleSection('throughput-multisignal')">Throughput Graph</button>
    <button id="btnPsd" onclick="toggleSection('psd_svg_figure_parent')">PSD Graph</button>
  </nav>
  <div style="display: flex;">
    <div style="display:inline-flex;">
    </div>
    <div class="grid-item">
      <div id="throughput-multisignal" class="hidden" style="width: 720px;">
      </div>
    </div>
    <!-- <div class="linkinputs" style="display: none;"> -->
    <div style="width: 25%;">
      <div class="bwMultiplierDiv" style="margin-top: 1rem; display: none;">
        <div style="font-size: 110%; color: #ff6b6b; display: inline-block;">Link 1</div>
        <label for="strategy" style="margin-left: 1rem;">BW mult.</label> &nbsp;
        <input style="width: 3.5rem;" id="multiplier1" type="text" value="1" oninput="this.value = this.value
        .replace(/[^0-9.]/g, '').replace(/(\..*?)\..*/g, '$1').replace(/^0[^.]/, '0').replace(/^[0.].*/, '');" />
      </div>
      <div class="iip3Div" style="margin-top: 1rem; margin-left: 1rem; display: none;">
        <label for="strategy">IIP3</label> &nbsp;
        <input style="width: 3.5rem;" id="iip3_1" type="text" value="0"
          oninput="this.value = this.value
        .replace(/[^0-9.-]/g, '').replace(/(\..*?)\..*/g, '$1').replace(/^0[^.]/, '0').replace(/^[-]*[0-9]+[.]*[0-9]*[-]/, '0');" />
      </div>

      <p>
        <input type="range" id=freq1 />
      </p>
      <p>
        <input type="range" id=bw1 style="display: none;" />
      </p>
      <p>
        <input type="range" id=gn1 style="display: none;"  />
      </p>
      <p>
        <input type="range" id=mcs1 style="display: none;" />
      </p>
    </div>


    <div style="width: 25%;">

      <div type="text" id="sinr_div"></div>

    </div>
    <!-- </div> -->
    <div class="grid-item">
      <div id="psd_svg_figure_parent" class="hidden"></div>
    </div>
  </div>
</body>
<script>

  // nav_bar toggle
  const sections = {
    'throughput-multisignal': false,
    'psd_svg_figure_parent': false
  };

  function toggleSection(sectionId) {
    // Toggle the section state
    sections[sectionId] = !sections[sectionId];

    // Show or hide the section based on its state
    document.getElementById(sectionId).classList.toggle('hidden', !sections[sectionId]);

    // If all sections are selected, show all sections
    if (Object.values(sections).every(state => state)) {
      Object.keys(sections).forEach(id => {
        document.getElementById(id).classList.remove('hidden');
      });
    }
  }




  'use strict';
  //These values initiated while loading



  let phi_offset = 0;
  // Receiver (Blue signal)
  var sig1 = Signal(JSON.parse(JSON.stringify(conf.signal_multi)), '', {
    // bw_max: 38.0e6, // Hz //this was 38 Hz, we needed to change this to 100
    bw_max:4.0e7,
    // bw_min: 4.0e6,  // Hz //this was 4 Hz, we needed to change this to -10
    bw_min: 0,
    bw_init: 4.0e6, // Hz
    gn_init: -10, // dB
    gn_min: -10, // dB
    gn_max:90,
    mcs_init: 6, // array index int
    freq_init: 1785.0e6
  });

  let distance_tx_rx = 0;

  // sig1['name'] = "comm_link_1";
  // sig2['name'] = "comm_link_2";
  // sig3['name'] = "comm_link_3";
  // sig4['name'] = "comm_link_4";

  var signalList = [sig1];
  var noise = Signal(conf.noise, "Noise", { gn_init: -120 })

  Slider(sig1, 'freq', '#freq1');
  Slider(sig1, 'bw', '#bw1');
  Slider(sig1, 'gn', '#gn1');
  Slider(sig1, 'mcs', '#mcs1');

  
 // updates sinr and pr values when ever there is a change in TX Slider
  document.querySelector('#gn1').addEventListener('input', function() {
    updatePathLoss();
  });

  document.querySelector('#freq1').addEventListener('input', function() {
    updatePathLoss();
  });

  // gn1.addEventListener("change", updatePathLoss());
  // Slider(sig1,'noise',"noise")

  //function calculate SINR as freq slider moved
  let slider_params = ['freq', 'bw', 'gn', 'mcs'];
  slider_params.forEach(param => {
    sig1._callbacks[param].push(CalculateSINR_BasedOn_ReceivedPower);
    CalculateSINR_BasedOn_ReceivedPower(sig1, sig1['_' + param]);
  })
  // Slider(noise, 'gn', '#gn2');

  Label(
    sig1,
    "sinr",
    {
      prefix: "Signal-to-Noise Ratio: SNR = ",
    },
    "sinr_div"
  );


  var receiverPos = new Position(0, 0, 0);
  var translatorPos = new Position(0, 0, 0);
  //setting default values of receiver power
  //overriding SNR and distance(tx and rx)
  getCoordinatesFromX3D("receiver");
  calcDistance(receiverPos, new Position(0, 0, 0));
  updatePathLoss();

  // HoppingInterferer(interferer, '#hoppingInterferer');
  CapacityBanner(sig1, '#capacityBanner');

  // function to listen to url changes
  window.onload = function () {
    const urlParams = new URLSearchParams(location.search);

    for (const [key, value] of urlParams) {
      let val = value.toLowerCase();
      if (key == 'mode' && ['beginner', 'advanced'].includes(val)) {
        document.getElementById(val).selected = "selected";
        onModeChange();
      }
    }
  };

  function onModeChange() {
    let mode = document.getElementById("mode").value;

    // beginner mode
    if (mode === 'beginner') {
      document.getElementById("ideal1").disabled = true;
      document.getElementById("ideal2").disabled = true;
      document.getElementById("ideal3").disabled = true;
      document.getElementById("nonlinear").disabled = true;
      document.getElementById("multiplierDiv").style.display = "none";
      document.getElementById("default").selected = "selected";
      document.getElementById('togglebutton').style.display = 'none';

      document.getElementById("bw1").style.display = "none";
      document.getElementById("gn1").style.display = "none";
      document.getElementById("mcs1").style.display = "none";
      document.getElementById("angles-table-tx").style.display = 'none';
      //document.getElementById("gn2").style.display = "initial";
      document.getElementById("sinr_div").style.display = "inline";

      Array.from(document.getElementsByClassName("bwMultiplierDiv")).forEach(element => {
        element.style.display = "none";
      });

      Array.from(document.getElementsByClassName("iip3Div")).forEach(element => {
        element.style.display = "none";
      });

      calculateSINR();

      document.getElementById('tx_pattern_options').style.display = 'none';
      document.getElementById("rotation_gizmo").setAttribute("whichChoice", -1);
      document.getElementById("tx-geometry").setAttribute("whichChoice", 0);
      document.getElementById('manual-angle-options-tx').style.display = 'none';
      document.getElementById('manual-angle-options-rx').style.display = 'none';


    } else if (mode === 'advanced') {
      document.getElementById("ideal1").disabled = false;
      document.getElementById("ideal2").disabled = false;
      document.getElementById("ideal3").disabled = false;
      document.getElementById("nonlinear").disabled = false;

      document.getElementById("bw1").style.display = "initial";
      document.getElementById("gn1").style.display = "initial";
      document.getElementById("mcs1").style.display = "initial";
      document.getElementById("angles-table-tx").style.display = "";
      //document.getElementById("gn2").style.display = "initial";
      document.getElementById('tx_pattern_options').style.display = 'inline-flex';
      document.getElementById("rotation_gizmo").setAttribute("whichChoice", 0);
      document.getElementById('manual-angle-options-tx').style.display = 'block';
      document.getElementById('manual-angle-options-rx').style.display = 'block';
      document.getElementById('togglebutton').style.display = 'block';


    }

  }


  function onCategoryChange() {
    let selection = document.getElementById("strategy").value;

    // ideal receiver filter with equal bandwidth multiplier for all signals
    if (selection == 'a1') {
      document.getElementById("multiplierDiv").style.display = "inline-block";
    } else {
      document.getElementById("multiplierDiv").style.display = "none";
    }

    // ideal receiver filter with unequal bandwidth multipliers 
    if (selection == 'a2' || selection == 'a4') {
      Array.from(document.getElementsByClassName("bwMultiplierDiv")).forEach(element => {
        element.style.display = "inline-block";
      });
    } else {
      Array.from(document.getElementsByClassName("bwMultiplierDiv")).forEach(element => {
        element.style.display = "none";
      });
    }

    // nonlinear frontend model
    if (selection == 'a4' || selection == 'a5') {
      Array.from(document.getElementsByClassName("iip3Div")).forEach(element => {
        element.style.display = "inline-block";
        sig1.nonlinearModel = true;

      });
    } else {
      Array.from(document.getElementsByClassName("iip3Div")).forEach(element => {
        element.style.display = "none";
      });
      sig1.nonlinearModel = false;


      sig1.iip3Point = null;
    }

  }

  // applies sinr calculation selection and triggers callbacks to calculate SINR
  function calculateSINR() {

    let selection = document.getElementById("strategy").value;

    if (selection == '') {
      sig1.bandwidthMultiplier = 1;

      sig1.nonlinearModel = false;

      sig1.iip3Point = null;

    }

    // ideal receiver filter with wider bandwidth than the received signal
    if (selection == 'a0') {
      sig1.bandwidthMultiplier = 1;

    }

    // ideal receiver filter with equal bandwidth multiplier for all signals
    if (selection == 'a1') {
      let bwMultiplier = document.getElementById("multiplier").value;
      if (bwMultiplier && bwMultiplier.length > 0) {
        let bw_m = Number(bwMultiplier);

        sig1.bandwidthMultiplier = bw_m;

      } else {
        return;
      }
    }

    // ideal receiver filter with unequal bandwidth multipliers 
    if (selection == 'a2' || selection == 'a4') {
      let bwMultiplier1 = document.getElementById("multiplier1").value;
      // let bwMultiplier2 = document.getElementById("multiplier2").value;
      // let bwMultiplier3 = document.getElementById("multiplier3").value;
      // let bwMultiplier4 = document.getElementById("multiplier4").value;

      // if (bwMultiplier1 && bwMultiplier2 && bwMultiplier3 && bwMultiplier4 &&
      //   bwMultiplier1.length > 0 && bwMultiplier2.length > 0 &&
      //   bwMultiplier3.length > 0 && bwMultiplier4.length > 0) {

      //   sig1.bandwidthMultiplier = Number(bwMultiplier1);

      // }
      if (bwMultiplier1 &&
        bwMultiplier1.length > 0) {

        sig1.bandwidthMultiplier = Number(bwMultiplier1);

      } else {
        return;
      }
    }

    // nonlinear frontend receiver filter 
    if (selection == 'a4' || selection == 'a5') {
      let iip3_1 = document.getElementById("iip3_1").value;
      //let iip3_2 = document.getElementById("iip3_2").value;


      // if (iip3_1 && iip3_2 && iip3_3 && iip3_4 &&
      //   iip3_1.length > 0 && iip3_2.length > 0 &&
      //   iip3_3.length > 0 && iip3_4.length > 0) {

      //   sig1.iip3Point = Number(iip3_1);

      // }
      if (iip3_1 && iip3_1.length > 0) {

        sig1.iip3Point = Number(iip3_1);

      } else {
        return;
      }
    }

    // nonlinear frontend receiver filter with excess bandwidth (preselector filter bandwidth)
    // occupying the enter frequency range
    if (selection == 'a5') {
      sig1.bandwidthMultiplier = -Infinity;

    }

    // trigger callbacks for all signals - (sinr and rate calculations and update plots)
    sig1.triggerCallbacks();
    //sinr value is changed where the formula is re-evaluated based on receiver 
    //distance instead of sig gain
    CalculateSINR_BasedOn_ReceivedPower();
  }

  window.addEventListener('load', (event) => {
    if (document.getElementById("scriptController2") != null) {
      document.getElementById("scriptController2").style.display = "none";
    }
  });

  ThroughputPlot(signalList);

  var funcs = null;

  // document.body.innerHTML+= `<div style="width: 720px; height: 320px;">
  //       <canvas id="spectral-efficiency-bar-chart" style="width: 720px"></canvas>
  //   </div>`

  SinrPlot_BarChart.init(signalList, "sinr-bar-chart", ["Link 1"]);
  SpectralEfficiencyPlot_BarChart.init(signalList, "spectral-efficiency-bar-chart", ["Link 1"]);

  var currentGizmoRotation_rx = new x3dom.fields.SFMatrix4f();
  var currentGizmoRotationOffset_rx = new x3dom.fields.SFMatrix4f();

  var currentGizmoRotation_tx = new x3dom.fields.SFMatrix4f();
  var currentGizmoRotationOffset_tx = new x3dom.fields.SFMatrix4f();

  /*
     * Callback function, invoked on translation gizmo output.
     */
  function processTranslationGizmoEvent(event) {

    if (event.fieldName === 'translation_changed') {
      //convert the sensor's output from sensor coordinates to world coordinates (i.e., include its 'axisRotation')
      let sensorToWorldMatrix = x3dom.fields.SFMatrix4f.parseRotation(event.target.getAttribute("axisRotation"));

      // console.log(event.value);

      let translationValue = sensorToWorldMatrix.multMatrixVec(event.value);

      translatorPos.x = translationValue.x;
      console.log("ANuj", translationValue.x);
      translatorPos.y = translationValue.y;
      translatorPos.z = translationValue.z;


      getCoordinatesFromX3D("receiver");
      calcDistance(receiverPos, translatorPos);


      phi_offset = 90 - Math.atan2(12, translatorPos.x) * 180 / Math.PI;

      // update path loss
      updatePathLoss();

      //transform the affected sensor geometry
      // document.getElementById('translationHandleTransform').setFieldValue('translation', translationValue);
      //document.getElementById('rotationHandleTransform').setFieldValue('translation', translationValue);
      //transform the affected element
      document.getElementById('transmitterTranslation').setFieldValue('translation', translationValue);
      applyRotationGizmoTransformations("translation-module");
    }
  }

  /*
   * Callback function, invoked on rotation gizmo output.
   */
  function processRotationGizmoEvent(event, module) {
    var sensorToWorldMatrix, rotationMatrixWorld;

    if (event.fieldName === 'rotation_changed') {
      //convert the sensor's output from sensor coordinates to world coordinates (i.e., include its 'axisRotation')
      sensorToWorldMatrix = x3dom.fields.SFMatrix4f.parseRotation(event.target.getAttribute("axisRotation"));
      rotationMatrixWorld = sensorToWorldMatrix.mult(event.value.toMatrix());

      //create an offset that applies the current rotation in world coordinates,
      //but doesn't change the orientation of the coordinate system
      if (module === "rx")
        currentGizmoRotationOffset_rx = rotationMatrixWorld.mult(sensorToWorldMatrix.inverse());
      else if (module === "tx")
        currentGizmoRotationOffset_tx = rotationMatrixWorld.mult(sensorToWorldMatrix.inverse());

      applyRotationGizmoTransformations(module);
      console.log(module + " : First cond");
    }

    if (event.fieldName === 'isActive' && event.value === false) {
      //incorporate the current rotation offset, interpreted globally, into the stored rotation value
      if (module === "rx") {
        currentGizmoRotation_rx = currentGizmoRotationOffset_rx.mult(currentGizmoRotation_rx);
        //reset current rotation offset to zero rotation
        currentGizmoRotationOffset_rx = new x3dom.fields.SFMatrix4f();
      }
      else if (module === "tx") {
        currentGizmoRotation_tx = currentGizmoRotationOffset_tx.mult(currentGizmoRotation_tx);
        //reset current rotation offset to zero rotation
        currentGizmoRotationOffset_tx = new x3dom.fields.SFMatrix4f();
      }


      applyRotationGizmoTransformations(module);
      console.log(module + " : Second cond");
    }
  }

  function getRotationNode(module) {
    if (module == "rx") {
      return document.getElementById('rxRotation');
    }
    return document.getElementById('txRotation');
  }

  /*
   * Applies the current transformations, computed from the rotation gizmo output, to the scene
   */
  function applyRotationGizmoTransformations(module) {
    //var transmitterRotationNode = getRotationNode(module);

    //incorporate the current rotation offset, interpreted globally, into the stored rotation value

    let transformMatrix_rx, transformMatrix_tx;
    if (module === "rx" || module === "translation-module") {
      transformMatrix_rx = currentGizmoRotationOffset_rx.mult(currentGizmoRotation_rx);
      let matrix_rx = [];
      for (let i = 0; i < 3; i++) {
        matrix_rx.push([transformMatrix_rx[`_${i}0`], transformMatrix_rx[`_${i}1`], transformMatrix_rx[`_${i}2`]]);
      }
      let angles_rx = transformMatrix_rx.getEulerAngles();

      // convert angles from radians to degrees
      let angleX_rx = ((angles_rx[0] * (180 / Math.PI)) + 360) % 360;
      let angleY_rx = ((angles_rx[1] * (180 / Math.PI)) + 360) % 360;
      let angleZ_rx = ((angles_rx[2] * (180 / Math.PI)) + 360) % 360;
      let thetaPhi_rx = anglesToThetaPhi(matrix_rx, "rx");

      // document.getElementById('angle-theta-table-' + module).textContent = thetaPhi[0].toFixed(2);
      // document.getElementById('angle-phi-table-' + module).textContent = thetaPhi[1].toFixed(2);

      // Print rotation angles in degrees
      // document.getElementById('angleX').textContent = 'Angle X: ' + angleX.toFixed(2);
      //document.getElementById('angle-x-table').textContent = angleX_rx.toFixed(2);
      document.getElementById('angle-x-table-rx').textContent = angleX_rx.toFixed(2);

      // document.getElementById('angleY').textContent = 'Angle Y: ' + angleY.toFixed(2);
      //document.getElementById('angle-y-table').textContent = angleY_rx.toFixed(2);
      document.getElementById('angle-y-table-rx').textContent = angleY_rx.toFixed(2);

      // document.getElementById('angleZ').textContent = 'Angle Z: ' + angleZ.toFixed(2);
      //document.getElementById('angle-z-table').textContent = angleZ_rx.toFixed(2);
      document.getElementById('angle-z-table-rx').textContent = angleZ_rx.toFixed(2);

      //set matrix value in column major format, as required by the MatrixTransform node
      document.getElementById('rxRotation').setFieldValue("matrix", transformMatrix_rx.transpose());
    }
    if (module === "tx" || module === "translation-module") {
      transformMatrix_tx = currentGizmoRotationOffset_tx.mult(currentGizmoRotation_tx);
      let matrix_tx = [];
      for (let i = 0; i < 3; i++) {
        matrix_tx.push([transformMatrix_tx[`_${i}0`], transformMatrix_tx[`_${i}1`], transformMatrix_tx[`_${i}2`]]);
      }

      // get the rotation angles in radians
      let angles_tx = transformMatrix_tx.getEulerAngles();
      let angleX_tx = ((angles_tx[0] * (180 / Math.PI)) + 360) % 360;
      let angleY_tx = ((angles_tx[1] * (180 / Math.PI)) + 360) % 360;
      let angleZ_tx = ((angles_tx[2] * (180 / Math.PI)) + 360) % 360;
      let thetaPhi_tx = anglesToThetaPhi(matrix_tx, "tx");

      // document.getElementById('angle-theta-table-' + module).textContent = thetaPhi[0].toFixed(2);
      // document.getElementById('angle-phi-table-' + module).textContent = thetaPhi[1].toFixed(2);

      // Print rotation angles in degrees
      // document.getElementById('angleX').textContent = 'Angle X: ' + angleX.toFixed(2);
      //document.getElementById('angle-x-table').textContent = angleX_tx.toFixed(2);
      document.getElementById('angle-x-table-tx').textContent = angleX_tx.toFixed(2);

      // document.getElementById('angleY').textContent = 'Angle Y: ' + angleY.toFixed(2);
      //document.getElementById('angle-y-table').textContent = angleY_tx.toFixed(2);
      document.getElementById('angle-y-table-tx').textContent = angleY_tx.toFixed(2);

      // document.getElementById('angleZ').textContent = 'Angle Z: ' + angleZ.toFixed(2);
      //document.getElementById('angle-z-table').textContent = angleZ_tx.toFixed(2);
      document.getElementById('angle-z-table-tx').textContent = angleZ_tx.toFixed(2);

      //set matrix value in column major format, as required by the MatrixTransform node
      document.getElementById('txRotation').setFieldValue("matrix", transformMatrix_tx.transpose());
    }

    // update path loss
    updatePathLoss();
  }

  function matrixMultiply(matrixA, matrixB) {
    if (matrixA[0].length !== matrixB.length) {
      throw new Error("Incompatible matrix dimensions for multiplication");
    }
    let result = [];
    for (let i = 0; i < matrixA.length; i++) {
      let sum = 0;
      for (let j = 0; j < matrixB.length; j++) {
        sum += matrixA[i][j] * matrixB[j][0];
      }
      result.push([sum]);
    }
    return result;
  }

  function cross_product_unit_vector(a_vector, b_vector) {
    var crossProduct = {
      x: a_vector.y * b_vector.z - a_vector.z * b_vector.y,
      y: a_vector.z * b_vector.x - a_vector.x * b_vector.z,
      z: a_vector.x * b_vector.y - a_vector.y * b_vector.x
    };
    // Calculate the magnitude (length) of the cross product
    var magnitude = Math.sqrt(
      crossProduct.x * crossProduct.x + crossProduct.y * crossProduct.y + crossProduct.z * crossProduct.z);
    // Calculate the unit vector
    var result_unit_vector = {
      x: crossProduct.x / magnitude,
      y: crossProduct.y / magnitude,
      z: crossProduct.z / magnitude
    };

    return result_unit_vector;
  }

  function dotProduct(a_vector, b_vector) {
    return a_vector.x * b_vector.x + a_vector.y * b_vector.y + a_vector.z * b_vector.z;
  }

  //1) In this case the receiver is always aligned with x3d scene +y axis (0, 1, 0)
  //2) initial line joining the Rx Pos and Tx Pos is -z axis (0, 0, -1)
  //3) The cross product ((-Z) x Y) gives +ve X axis
  //4) line in (2) is always the new -z axis and (3) is always the new +ve X axis
  //5) from the considerations we can get the x axis  
  function calculateUpdatedAngles(x_initial, y_initial, z_initial, module) {
    var magnitud1 = Math.sqrt(
      x_initial * x_initial + y_initial * y_initial + z_initial * z_initial);
    //Here receiver means transmitter
    var rx_coordinates = getCoordinatesFromX3D("receiver");
    var tx_cordinates = translatorPos;
    var updated_z_vector = {
      x: -(rx_coordinates.x - tx_cordinates.x), y: -(rx_coordinates.y - tx_cordinates.y),
      z: -(rx_coordinates.z - tx_cordinates.z)
    };
    var updated_z_magnitude = Math.sqrt(updated_z_vector.x * updated_z_vector.x
      + updated_z_vector.y * updated_z_vector.y + updated_z_vector.z * updated_z_vector.z);

    updated_z_vector.x = updated_z_vector.x / updated_z_magnitude;
    updated_z_vector.y = updated_z_vector.y / updated_z_magnitude;
    updated_z_vector.z = updated_z_vector.z / updated_z_magnitude;
    var initial_y_vector = { x: 0, y: 1, z: 0 };
    var updated_x_vector = cross_product_unit_vector(initial_y_vector, updated_z_vector);
    var updated_y_vector = cross_product_unit_vector(updated_z_vector, updated_x_vector);
    var x_new = dotProduct({
      x: x_initial, y: y_initial,
      z: z_initial
    }, updated_x_vector);
    var y_new = dotProduct({
      x: x_initial, y: y_initial,
      z: z_initial
    }, updated_y_vector);
    var z_new = dotProduct({
      x: x_initial, y: y_initial,
      z: z_initial
    }, updated_z_vector);
    var magnitude = Math.sqrt(
      x_new * x_new + y_new * y_new + z_new * z_new);

    var angles_updated = calculatePolarAngles(x_new, y_new, z_new);

    if (angles_updated[1] > 360)
      angles_updated[1] = angles_updated[1] % 360;

    if (module === "translation-module" || module === "rx") {
      /*update angles of rx w.r.t tx*/
      document.getElementById('angle-theta-table-rx-rel').textContent = angles_updated[0].toFixed(2);
      document.getElementById('angle-phi-table-rx-rel').textContent = angles_updated[1].toFixed(2);
      console.log("rx angles", angles_updated[0], angles_updated[1])
    }

    if (module === "translation-module" || module === "tx") {
      /*update angles of tx w.r.t rx*/
      angles_updated[1] = (540 - angles_updated[1]) % 360;
      document.getElementById('angle-theta-table-tx-rel').textContent = angles_updated[0].toFixed(2);
      document.getElementById('angle-phi-table-tx-rel').textContent = angles_updated[1].toFixed(2);
      console.log("tx angles", angles_updated[0], angles_updated[1])
    }

  }

  function calculatePolarAngles(x, y, z) {
    let radius = Math.sqrt(x * x + y * y + z * z);
    let theta = Math.acos(y / radius); // Theta angle in radians
    let phi = Math.atan2(z, x); // Phi angle in radians
    theta = theta * (180 / Math.PI);
    phi = phi * (180 / Math.PI);
    if (phi < 0)
      phi = phi + 360;
    return [theta, phi];
  }

  function calculateGlobalAngles(x, y, z) {
    let radius = Math.sqrt(x * x + y * y + z * z);
    let theta = Math.acos(y / radius); // Theta angle in radians
    let phi = Math.atan2(-z, x); // Phi angle in radians
    theta = theta * (180 / Math.PI);
    phi = phi * (180 / Math.PI);
    phi = (phi - 270 + 360) % 360;
    theta = (270 - theta) % 180;
    if (phi < 0)
      phi = (phi + 360) % 360;
    console.log("Theta(Original): " + theta);
    console.log("Phi(Original): " + phi);
    return [theta, phi];
  }

  function anglesToThetaPhi(matrix, module) {
    let matrixB = [[0], [0], [1]];
    console.log("module", module);
    console.log(typeof (module));

    let resultCoordMatrix = matrixMultiply(matrix, matrixB);
    calculateUpdatedAngles(resultCoordMatrix[0], resultCoordMatrix[1],
      resultCoordMatrix[2], module);
    return calculateGlobalAngles(resultCoordMatrix[0], resultCoordMatrix[1],
      resultCoordMatrix[2]);
  }

  // Updates the Path Loss
  function updatePathLoss() {
    let pattern_rx = document.getElementById("antenna_pattern").value;
    let pattern_tx = document.getElementById("tx_pattern").value;

    let theta_rx = Number(document.getElementById("angle-theta-table-rx-rel").innerText) || 0;
    let phi_rx = Number(document.getElementById("angle-phi-table-rx-rel").innerText) || 0;

    let theta_tx = Number(document.getElementById("angle-theta-table-tx-rel").innerText) || 0;
    let phi_tx = Number(document.getElementById("angle-phi-table-tx-rel").innerText) || 0;
    //calculatePathLoss(sig1, theta_rx, phi_rx, distance_tx_rx, pattern_rx);
    let mode = document.getElementById("mode").value;

    console.log(pattern_rx, theta_rx, phi_rx);
    console.log(pattern_tx, theta_tx, phi_tx);
    // beginner mode
    if (mode === 'beginner') {
      calculatePathLoss(sig1, theta_rx, phi_rx, distance_tx_rx, pattern_rx)
    }
    else {
      calculatePathLossAdvanced(sig1, theta_rx, phi_rx, theta_tx, phi_tx, distance_tx_rx, pattern_rx, pattern_tx);
    }

    // var x3d_pr =document.getElementById("power_rx_db").innerHTML;
    // var x3d_bw=sig1.bw/1000000;
    // // var x3d_gain=x3d_pr - 10 * Math.log10(x3d_bw);
    // var test_var=x3d_pr - 10 * Math.log10(x3d_bw);

    //connection b/w x3d and slider
    // sig1.gn=x3d_pr - 10 * Math.log10(x3d_bw);
    PowerSpectrumPlot_2D()
    // console.log(gn1.value," ajshdgbhjdhbvhjsabvhjfbsvurbvreuik",test_var);



    //sinr value is changed where the formula is re-evaluated based on receiver 
    //distance instead of sig gain
    CalculateSINR_BasedOn_ReceivedPower();
  }

  function CalculateSINR_BasedOn_ReceivedPower() {
    let power_Receiver_dB = document.getElementById("power_rx_db").innerHTML;
    if (sig1.nonlinearModel == false) {
      let t_ccip = sig1.calculateSINR(null, false)[0];
      console.log(t_ccip,"@@###@#@#@")
      // sig1._sinr = Number(power_Receiver_dB) - 10 * Math.log10(t_ccip); changing this line to a new formula based on 8/21/2024 discussion
      band=sig1.bw;
      sig1._sinr=Number(power_Receiver_dB)- 10*Math.log10(band)-(-120);
      console.log("Sinr",sig1._sinr,10*Math.log10(band));
      // keeping this fix since ccip doesn't consider path loss and this will
      if(sig1._sinr >= conf.schemes[sig1._mcs].SNR){
        sig1._rate = sig1._bw * conf.schemes[sig1._mcs].rate;
      }else{
        sig1._rate = 0.1;
      }
      
      
      
      sig1._callbacks.sinr.forEach(function (callback) {
        callback(sig1, sig1._sinr);
      });
      console.log("Rate",sig1._rate)

    }
    else {
      // sig1._sinr = Number(power_Receiver_dB) - 10 * Math.log10(sig1._non_linear_ccip);
      band=sig1.bw;
      sig1._sinr=Number(power_Receiver_dB)- 10*Math.log10(band)-(-120);
      sig1._callbacks.sinr.forEach(function (callback) {
        callback(sig1, sig1._sinr);
      });
    }
  }




  window.onload = function () {
    getCoordinatesFromX3D("receiver");
    const transmitterNode = document.getElementById("transmitterPlane");
    const axisRotationAttr = transmitterNode.getAttribute("axisRotation");

    let transmitterObj = document.getElementById("transmitterPlane");
    let sensorToWorldMatrix = x3dom.fields.SFMatrix4f.parseRotation(transmitterObj.getAttribute("axisRotation"));
    // let translationValue = sensorToWorldMatrix.multMatrixVec(event.value);

    calcDistance(translatorPos, receiverPos);
  };
  function getCoordinatesFromX3D(objectName) {

    const transformNode = document.getElementById(objectName);
    if (!transformNode) {
      console.error(`Object "${objectName}" not found in X3D file.`);
      return null;
    }

    // Get the translation attribute of the Transform node
    const translationAttr = transformNode.getAttribute("translation");

    // Parse the translation attribute string into an array of coordinates
    const coordinates = translationAttr.split(" ").map(parseFloat);
    // console.log(coordinates);
    receiverPos.x = coordinates[0];
    receiverPos.y = coordinates[1];
    receiverPos.z = coordinates[2];
    //console.log(receiverPos);

    // Return the coordinates as an object with x, y, and z properties
    return { x: coordinates[0], y: coordinates[1], z: coordinates[2] };
  }

  function calcDistance(P1, P2) {
    // P1 = (x1, y1, z1); P2 = (x2, y2, z2)
    var a = P2.x - P1.x;
    var b = P2.y - P1.y;
    var c = P2.z - P1.z;

    var distance = Math.sqrt(a * a + b * b + c * c);
    distance_tx_rx = distance;
    document.getElementById("rec_trans_dist").innerHTML = distance.toFixed(2);

  }
  PowerSpectrumPlot_2D();

  const rx_verticalCheckbox = document.getElementById("vertical_rx");
  const rx_horizontalCheckbox = document.getElementById("horizontal_rx");

  const tx_verticalCheckbox = document.getElementById("vertical_tx");
  const tx_horizontalCheckbox = document.getElementById("horizontal_tx");

  document.getElementById("antenna_pattern").addEventListener("change", selectModel);
  document.getElementById("tx_pattern").addEventListener("change", selectModel);
  rx_verticalCheckbox.addEventListener("change", selectModel);
  rx_horizontalCheckbox.addEventListener("change", selectModel);

  tx_verticalCheckbox.addEventListener("change", selectModel);
  tx_horizontalCheckbox.addEventListener("change", selectModel);
  onModeChange();

  function selectModel() {
    const selectedValue_rx = document.getElementById("antenna_pattern").selectedIndex;
    const selectedValue_tx = document.getElementById("tx_pattern").selectedIndex;
    const rx_isCheckedVertical = rx_verticalCheckbox.checked ? 1 : 0;
    const rx_isCheckedHorizontal = rx_horizontalCheckbox.checked ? 1 : 0;
    const tx_isCheckedVertical = tx_verticalCheckbox.checked ? 1 : 0;
    const tx_isCheckedHorizontal = tx_horizontalCheckbox.checked ? 1 : 0;
    const modelNumber_rx = (selectedValue_rx) * 4 + 2 * rx_isCheckedVertical + rx_isCheckedHorizontal;
    console.log(modelNumber_rx);
    let modelNumber_tx = 0;
    if (document.getElementById("mode").value != 'beginner')
      modelNumber_tx = (selectedValue_tx) * 4 + 2 * tx_isCheckedVertical + tx_isCheckedHorizontal;
    console.log("test");
    console.log(modelNumber_tx);
    document.getElementById("receiver-geometry").setAttribute("whichchoice", modelNumber_rx);
    if (document.getElementById("mode").value == 'beginner') {
      document.getElementById("tx-geometry").setAttribute("whichchoice", 0);
    }
    else
      document.getElementById("tx-geometry").setAttribute("whichchoice", modelNumber_tx);

  }

  function manualInput() {
    let theta_tx = Number(document.getElementById("theta_tx_manual").value);
    let phi_tx = Number(document.getElementById("phi_tx_manual").value);
    let theta_rx = Number(document.getElementById("theta_rx_manual").value);
    let phi_rx = Number(document.getElementById("phi_rx_manual").value);
    let pattern = document.getElementById("antenna_pattern").value;

    console.log("Manual pattern is: " + pattern);

    document.getElementById('angle-theta-table-tx').textContent = theta_tx;
    document.getElementById('angle-phi-table-tx').textContent = phi_tx;

    document.getElementById('angle-theta-table-rx').textContent = theta_rx;
    document.getElementById('angle-phi-table-rx').textContent = phi_rx;

    if (theta_tx < 0 || theta_tx > 180 || phi_tx < 0 || phi_tx > 360 ||
      theta_rx < 0 || theta_rx > 180 || phi_rx < 0 || phi_rx > 360) {
      console.log("Invalid input for theta/phi");
      return;
    }
    calculatePathLossAdvanced(sig1, theta_rx, phi_rx, theta_tx, phi_tx, distance_tx_rx, pattern);
  }

  document.addEventListener('DOMContentLoaded', function () {
    var verticalSlider = document.getElementById('sliderForVertical');
    var horizontalSlider = document.getElementById('sliderForHorizontal');
    var rotateXSlider = document.getElementById('sliderForRotateX');
    var rotateYSlider = document.getElementById('sliderForRotateY');
    var transmitterTransform = document.getElementById('rxRotation');

    // var verticalSlider2 = document.getElementById('slider2ForVertical');
    // var horizontalSlider2 = document.getElementById('slider2ForHorizontal');
    var rotateXSlider2 = document.getElementById('slider2ForRotateX');
    var rotateYSlider2 = document.getElementById('slider2ForRotateY');

    if (!transmitterTransform) {
      console.error('Transmitter Transform not found');
      return;
    }

    verticalSlider.addEventListener('input', function () {
      updateTranslation(verticalSlider.value, null);
    });

    horizontalSlider.addEventListener('input', function () {
      updateTranslation(null, horizontalSlider.value);
    });

    rotateXSlider.addEventListener('input', function () {
      updateRotation(rotateXSlider.value, null);
    });

    rotateYSlider.addEventListener('input', function () {
      updateRotation(null, rotateYSlider.value);
    });

    // toggle

    rotateXSlider2.addEventListener('input', function () {
      updateRotation(rotateXSlider2.value, null);
    });

    rotateYSlider2.addEventListener('input', function () {
      updateRotation(null, rotateYSlider2.value);
    });

    function updateTranslation(newX, newZ) {
      var currentTranslation = transmitterTransform.getAttribute('translation');
      var translationComponents = currentTranslation.split(' ');
      if (newX !== null) translationComponents[0] = newX;
      if (newZ !== null) translationComponents[2] = newZ;
      transmitterTransform.setAttribute('translation', translationComponents.join(' '));
      console.log('Updated translation:', translationComponents.join(' '));
    }

    function updateRotation(newX, newY) {
      var currentRotation = transmitterTransform.getAttribute('rotation');
      var rotationComponents = currentRotation ? currentRotation.split(' ') : [0, 0, 0, 0];

      if (newX !== null) {
        rotationComponents[3] = newX * Math.PI / 180; // Convert degrees to radians
        rotationComponents[0] = 1; // Rotate around x-axis
        rotationComponents[1] = 0;
        rotationComponents[2] = 0;
      }

      if (newY !== null) {
        rotationComponents[3] = newY * Math.PI / 180; // Convert degrees to radians
        rotationComponents[0] = 0;
        rotationComponents[1] = 1; // Rotate around y-axis
        rotationComponents[2] = 0;
      }

      transmitterTransform.setAttribute('rotation', rotationComponents.join(' '));
      console.log('Updated rotation:', rotationComponents.join(' '));
    }
  });

  let toggleValue = "RX";

  // Function to toggle the value
  function toggleSliders() {
    // var x3d_pr =document.getElementById("power_rx_db").innerHTML;
    // var x3d_bw=sig1.bw/1000000;
    // // var x3d_gain=x3d_pr - 10 * Math.log10(x3d_bw);
    // var anuj=x3d_pr - 10 * Math.log10(x3d_bw);
    // sig1.gn=x3d_pr - 10 * Math.log10(x3d_bw);
    // console.log(gn1.value," ajshdgbhjdhbvhjsabvhjfbsvurbvreuik",anuj);
    // gn1.value=;
    var div = document.getElementById('sliderGroup2');
    // var div2 = document.getElementById('sliderGroup2Left');
    var div3 = document.getElementById('sliderLeft');
    var div4 = document.getElementById('sliderRight');
    var div5 = document.getElementById('sliderBottom');
    var div6 = document.getElementById('sliderRight2');

    if (div.style.display === 'none') {
      div.style.display = 'block';
      // div2.style.display = 'block';
      div3.style.display = 'none';
      div4.style.display = 'none';
      div5.style.display = 'none';
      div6.style.display = 'block';

    } else {
      div.style.display = 'none';
      // div2.style.display = 'none';
      div3.style.display = 'flex';
      div4.style.display = 'inherit';
      div5.style.display = 'inherit';
      div6.style.display = 'none'
    }
    toggleValue = (toggleValue === "RX") ? "TX" : "RX";
    document.getElementById('toggle-button').style.backgroundColor = (toggleValue === "RX") ? "#00ffff" : "red";
    console.log("Toggled Value:", toggleValue);
    toggleValueDisplay.textContent = `You are Controlling: ${toggleValue} "Press to toggle"`;

  }



  let globalTransformMatrix = x3dom.fields.SFMatrix4f.identity();
  let lastSliderValue = { X: 0, Y: 0, Z: 0 }; // to store the last slider values
  const translationState = { X: 0, Y: 0, Z: 0 }; // to store translation states

  // Helper function to apply rotation around Y axis to the current transformation matrix
  function applyRotationY(angleInDegrees) {
    const angleInRadians = angleInDegrees * (Math.PI / 180);
    const rotationMatrixY = x3dom.fields.SFMatrix4f.rotationY(angleInRadians);
    globalTransformMatrix = rotationMatrixY.mult(globalTransformMatrix);
    return globalTransformMatrix;
  }

  // Helper function to apply rotation around X axis to the current transformation matrix
  function applyRotationX(angleInDegrees) {
    const angleInRadians = angleInDegrees * (Math.PI / 180);
    const rotationMatrixX = x3dom.fields.SFMatrix4f.rotationX(angleInRadians);
    globalTransformMatrix = rotationMatrixX.mult(globalTransformMatrix);
    return globalTransformMatrix;
  }

  function setupSlider(sliderId, module, axis, isTranslation = false) {
    document.getElementById(sliderId).addEventListener('input', function (event) {
      const currentSliderValue = parseFloat(event.target.value);
      const deltaValue = currentSliderValue - lastSliderValue[axis]; // Calculate the change in value

      if (isTranslation) {
        // Incrementally update the translation state
        translationState[axis] = currentSliderValue;

        // Create the translation event with the updated state
        var translationEvent = {
          fieldName: 'translation_changed',
          target: { getAttribute: function (attr) { return '0 0 0 0'; } }, // Dummy function for example
          value: new x3dom.fields.SFVec3f(
            translationState.X,
            translationState.Y,
            translationState.Z
          )
        };

        processTranslationGizmoEvent(translationEvent);
      } else {
        // Rotation handling
        let combinedRotationMatrix;
        if (axis === 'Y') {
          combinedRotationMatrix = applyRotationY(deltaValue); // Apply the change in value
          globalTransformMatrix = combinedRotationMatrix;
        } else {
          const angleInRadiansX = deltaValue * (Math.PI / 180);
          const rotationMatrixX = x3dom.fields.SFMatrix4f.rotationX(angleInRadiansX);
          globalTransformMatrix = rotationMatrixX.mult(globalTransformMatrix);
        }

        var rotationEvent = {
          fieldName: 'rotation_changed',
          value: {
            toMatrix: function () {
              return globalTransformMatrix;
            }
          },
          target: {
            getAttribute: function () {
              return '0 0 0 0'; // Dummy target attribute
            }
          }
        };

        processRotationGizmoEvent(rotationEvent, module);
      }

      lastSliderValue[axis] = currentSliderValue; // Update the last slider value

      updatePathLoss();
    });
  }

  

  // Set up sliders for rotation
  setupSlider('sliderForRotateX', 'rx', 'X');
  setupSlider('sliderForRotateY', 'rx', 'Y');
  // Set up sliders for translation
  setupSlider('sliderForHorizontal', 'rx', 'X', true); // Horizontal translation
  setupSlider('sliderForVertical', 'rx', 'Z', true); // Vertical translation

  //Toggle
  setupSlider('slider2ForRotateX', 'tx', 'X');
  setupSlider('slider2ForRotateY', 'tx', 'Y');


  // Set up sliders for translation
  // setupSlider('slider2ForHorizontal', 'tx', 'X', true); // Horizontal translation
  // setupSlider('slider2ForVertical', 'tx', 'Z', true); // Vertical translation


  document.addEventListener('DOMContentLoaded', function () {
    var rotateXSlider = document.getElementById('sliderForRotateX');
    var rotateYSlider = document.getElementById('sliderForRotateY');
    // var rotateZSlider = document.getElementById('sliderForRotateZ');
    var slider2ForRotateX = document.getElementById('slider2ForRotateX')

    



    var objectTransform = document.getElementById('rotationHandleTransform');

    if (!objectTransform) {
      console.error('Rotation Handle Transform not found');
      return;
    }

    rotateXSlider.addEventListener('input', function () {
      var angleRadians = this.value * Math.PI / 180;
      console.log('Rotate X:', angleRadians);
    });

    rotateYSlider.addEventListener('input', function () {
      var angleRadians = this.value * Math.PI / 180;
      console.log('Rotate Y:', angleRadians);
    });

    rotateZSlider.addEventListener('input', function () {
      var angleRadians = this.value * Math.PI / 180;
      console.log('Rotate Z:', angleRadians);
      objectTransform.setAttribute('rotation', `0 0 1 ${angleRadians}`);

    });
  });

</script>

</html>