<!DOCTYPE html>
<html>

<head>
  <title>Antenna Radiating Patterns</title>
</head>

<body>
  <h1>Antenna Radiating Patterns</h1>

  <h2>Vertically polarized isotropic antenna</h2>
  <h2>Horizontally polarized isotropic antenna</h2>
  <h2>Vertically oriented half-wave dipole antenna</h2>
  <h2>Vertically oriented small dipole antenna</h2>
  <h2>Directional antenna with a flat main beam and uniform side lobe level</h2>


  <script>
    window.onload = (event) => {

      let thetaresolution = 10;
      let phiresolution = 10;

      // vertically polarized isotropic antenna
      function isovert(thetares, phires) {
        if (90 % thetares !== 0) {
          console.log("Error! Theta resolution must divide evenly into 90 degrees.");
          return;
        }

        let thetadim = 180 / thetares + 1;
        let phidim = 360 / phires + 1;

        let fvert = Array(thetadim)
          .fill()
          .map(() => Array(phidim).fill(1)); // vertical polarization

        let fhoriz = Array(thetadim)
          .fill()
          .map(() => Array(phidim).fill(0)); // horizontal polarization

        console.log(fvert);
        console.log(fhoriz);
      }

      // horizontally polarized isotropic antenna
      function isohoriz(thetares, phires) {
        if (90 % thetares !== 0) {
          console.log("Error! Theta resolution must divide evenly into 90 degrees.");
          return;
        }

        let thetadim = 180 / thetares + 1;
        let phidim = 360 / phires + 1;

        let fvert = Array(thetadim)
          .fill()
          .map(() => Array(phidim).fill(0)); // vertical polarization

        let fhoriz = Array(thetadim)
          .fill()
          .map(() => Array(phidim).fill(1)); // horizontal polarization

        console.log(fvert);
        console.log(fhoriz);

      }

      // vertically oriented half-wave dipole antenna
      function halfwave(thetares, phires) {
        if (90 % thetares !== 0) {
          console.log("Error! Theta resolution must divide evenly into 90 degrees.");
          return;
        }

        let thetadim = 180 / thetares + 1;
        let phidim = 360 / phires + 1;

        let fvert = Array(thetadim)
          .fill()
          .map(() => Array(phidim).fill(0)); // vertical polarization
        let fhoriz = fvert.slice(); // horizontal polarization

        for (let k = 0; k < thetadim; k++) {
          let theta = (Math.PI * thetares * k) / 180;
          for (let m = 0; m < phidim; m++) {
            let phi = (Math.PI * phires * m) / 180;
            if (k === 0 || k === thetadim - 1) {
              fvert[k][m] = 0;
            } else {
              fvert[k][m] = Math.cos((Math.PI / 2) * Math.cos(theta)) / Math.sin(theta);
            }
          }
        }

        console.log(fvert);
        console.log(fhoriz);

      }

      // vertically oriented small dipole antenna
      function sloop(thetares, phires) {
        if (90 / thetares !== Math.round(90 / thetares)) {
          console.log('Error!  theta resolution must divide evenly into 90 degrees.');
          return;
        }

        let thetadim = 180 / thetares + 1;
        let phidim = 360 / phires + 1;

        let fvert = [];
        let fhoriz = [];
        for (let i = 0; i < thetadim; i++) {
          fvert.push(new Array(phidim).fill(0));
          fhoriz.push(new Array(phidim).fill(0));
        }

        for (let k = 1; k <= thetadim; k++) {
          let theta = Math.PI * thetares * (k - 1) / 180;
          for (let m = 1; m <= phidim; m++) {
            let phi = Math.PI * phires * (m - 1) / 180;
            fvert[k - 1][m - 1] = Math.sin(theta);
          }
        }

        console.log(fvert);
        console.log(fhoriz);

      }

      // directional, vertically polarized antenna with specified horizontal and vertical beamwidth and sidelobe level
      // Generates the pattern for a vertically polarized directional antenna with a flat main beam and uniform side lobe level.
      function dirantv(thetares, phires, azbw, elbw, SLL) {
        if (SLL > 0) {
          console.log("Error! SLL must be <= 0.");
          return;
        }

        if (90 / thetares !== Math.round(90 / thetares)) {
          console.log("Error! theta resolution must divide evenly into 90 degrees.");
          return;
        }

        const thetadim = 180 / thetares + 1;
        const phidim = 360 / phires + 1;

        const fvert = Array.from({ length: thetadim }, () => Array.from({ length: phidim }).fill(0));
        const fhoriz = Array.from({ length: thetadim }, () => Array.from({ length: phidim }).fill(0));

        for (let k = 1; k <= thetadim; k++) {
          const theta = Math.PI * thetares * (k - 1) / 180;
          for (let m = 1; m <= phidim; m++) {
            const phi = Math.PI * phires * (m - 1) / 180;
            if (Math.abs(theta - Math.PI / 2) - Math.PI * thetares / 1800 > Math.PI * (elbw / 2) / 180) {
              if (SLL !== -999) {
                fvert[k - 1][m - 1] = 10 ** (SLL / 10);
              }
            } else if (phi - Math.PI * phires / 1800 > (azbw / 2) * Math.PI / 180 && (2 * Math.PI - phi) > (azbw / 2) * Math.PI / 180 + Math.PI * phires / 1800) {
              if (SLL !== -999) {
                fvert[k - 1][m - 1] = 10 ** (SLL / 10);
              }
            } else {
              fvert[k - 1][m - 1] = 1;
            }
          }
        }

        console.log(fvert);
        console.log(fhoriz);

      }


      // method invocations
      isovert(thetaresolution, phiresolution);
      isohoriz(thetaresolution, phiresolution);
      halfwave(thetaresolution, phiresolution);
      sloop(thetaresolution, phiresolution);
      dirantv(thetaresolution, phiresolution, 20, 20, -1.5);

    };
  </script>
</body>

</html>